{"meta":{"title":"友云音FED","subtitle":null,"description":"友云音，友云音前端团队，友云音FED，用友APM","author":"youyunyin","url":"http://youyunyin.com"},"pages":[{"title":"微信公众号javaweb全栈之路","date":"2019-01-19T08:20:09.879Z","updated":"2019-01-19T08:20:09.879Z","comments":false,"path":"about/index.html","permalink":"http://youyunyin.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-01-19T08:20:09.879Z","updated":"2019-01-19T08:20:09.879Z","comments":false,"path":"categories/index.html","permalink":"http://youyunyin.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-01-19T08:20:10.033Z","updated":"2019-01-19T08:20:10.033Z","comments":true,"path":"links/index.html","permalink":"http://youyunyin.com/links/index.html","excerpt":"","text":""},{"title":"前端导航","date":"2019-01-19T08:20:10.033Z","updated":"2019-01-19T08:20:10.033Z","comments":false,"path":"nav/index.html","permalink":"http://youyunyin.com/nav/index.html","excerpt":"","text":"导航"},{"title":"Repositories","date":"2019-01-19T08:20:10.034Z","updated":"2019-01-19T08:20:10.034Z","comments":false,"path":"repository/index.html","permalink":"http://youyunyin.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-01-19T08:20:10.034Z","updated":"2019-01-19T08:20:10.034Z","comments":false,"path":"tags/index.html","permalink":"http://youyunyin.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"'命令中的-和--'","slug":"命令中的-和","date":"2019-01-17T05:56:23.000Z","updated":"2019-01-19T08:20:09.867Z","comments":true,"path":"2019/01/17/命令中的-和/","link":"","permalink":"http://youyunyin.com/2019/01/17/命令中的-和/","excerpt":"","text":"命令中的-和–经常用命令行的同学，对-和--符号肯定都不陌生，它们多用于配置命令的选项，例如：npm install -d，git config --global那这两个符号又有什么区别呢？ 这种格式的选项源于*nix系统的命令行中，其中单短划线-用于一个字符的配置，双短划线--用于多字符场景，二者都表示可选配置项。 但是，除了这种用法之外，不是也经常会碰到单短划线后多个字符，甚至还有不带任何字符的双短划线的时候，那这又表示什么呢？12345# 单短划线后多个配置项tar -cxf# 不带任何字符的双短划线npm test -- --coverage 单短划线后带多个字符，实际上就是多个-*的缩略写法，例如：dir -tl等价于dir -t -l。 双短划线独立使用的时候，它起到的是选项结束符的作用，而后出现的参数将被视为操作数，而非选项，即使他们以-开头。下面举两个例子说明：在终端输入ls -l，此命令将以列表格式输出当前目录内容，而ls -- -l将输出ls: cannot access &#39;-l&#39;: No such file or directory，在这里，-l被当作了文件名。","categories":[],"tags":[]},{"title":"js探针安装说明","slug":"js探针安装说明","date":"2019-01-14T07:43:35.000Z","updated":"2019-01-19T08:20:09.867Z","comments":true,"path":"2019/01/14/js探针安装说明/","link":"","permalink":"http://youyunyin.com/2019/01/14/js探针安装说明/","excerpt":"","text":"友云音Browser探针安装说明友云音Browser使用JavaScript代码（JS SDK：yonyou-yyy.js，又称为探针）监控您的网页应用。每个探针都关联着系统分配给您的租户ID（tid）和应用ID（appid），最终您将在对应的租户应用中看到我们的统计分析数据。本文介绍如何将SDK安装到您的网站中。 获取SDK 登录友云音，进入“应用管理”界面。 选择需要监控的Browser类型应用，点击下载图标进入SDK下载界面。 选择“应用探针”节点，点击“下载探针”直接下载文件，或者使用“在线脚本”从我们的服务器动态加载： 点击“下载探针”直接下载文件 注：下载的文件为zip格式的压缩文件，需要解压后使用。 使用“在线脚本”从我们的服务器动态加载 安装SDK安装SDK指通过一定的方式，使得加载网站页面的时候，可以引入探针文件。探针文件可以通过直接下载或在线安装方式获取。 直接下载指的是从友云音服务器将探针文件下载到本地，然后将其部署到您的应用服务器，访问网站时浏览器将从您的应用服务器加载探针； 在线安装指的是每次打开网站时，浏览器直接从友云音服务器获取探针。 NC portal应用 将下载的压缩文件解压后，复制yonyou-yyy.js到 {nchome}/hotwebs/portal目录下。 NC portal应用只能选择直接下载的方式进行安装 其它WEB应用可根据需要选择直接下载或者在线安装任一方式。代码安装过程中需要注意以下几点： 代码的安装位置要正确，请将代码段添加在标签&lt;head&gt;标记中尽量靠前的位置，但要放在某些对位置比较敏感的&lt;meta&gt;标签之后（例如X-UA-Compatible或charset信息）。建议添加到公共页面头部，这样可以减少工作量。如果没有公共页面，也可以考虑添加到公共JS中，但这样可能会造成数据采集不完整。 一个页面中不要重复添加相同的代码，统计有去重规则，一般不会重复计算。一段代码生效后，另外一段代码就会废弃，但建议只添加一段代码。 使用在线脚本的方式安装时，请不要删除src值中的tid和appid参数值，否则SDK将不可用 如果是直接下载的文件，需要解压后放到某路径下（“{your/path/}”），再执行以下步骤。 正确的tid和appid是探针正常运行的前提条件。直接下载的探针文件中已包含了这两个字段的值，所以在安装代码段中不必再次指定。再次强调：在线安装时，请不要修改或删除src中预设的tid和appid参数值。 异步方式1234567891011121314151617181920&lt;script&gt; var _yyy = _yyy || []; (function() &#123; _yyy.push([metric1, literal]); _yyy.push([metric2, function]); // 可添加更多监控项或配置项 // ... // 创建script节点以加载探针 var s = document.createElement(&quot;script&quot;); // 指定src属性：下面的（1）和（2）根据情况选择其中一种 // （1）直接下载到本地安装，假定JS探针的部署路径为“&#123;your/path/&#125;” s.src = &quot;&#123;your/path&#125;/yonyou-yyy.js&quot;; // （2）使用“在线脚本”的方式安装，需要指定tid和appid的值（下载页面已预设，不要删除或修改，否则SDK将不可用！） // 也可以将src属性值中的“https://yyy.yonyoucloud.com”替换为&#123;your/path&#125;，从本地加载 s.src = &quot;https://yyy.yonyoucloud.com/yonyou-yyy.js?tid=***&amp;appid=***&quot;; var t = document.getElementsByTagName(&quot;script&quot;)[0]; t.parentNode.insertBefore(s, t); &#125;)();&lt;/script&gt; 如果是通过js脚本加载，请将上面代码段中&lt;script&gt;标签内部的文本复制到相应的js中。 同步方式虽然异步方式可以小幅提升页面加载性能，但仍然推荐以同步方式加载探针，因为我们对浏览器内置的一些API作了包装，提前执行脚本可提高监控准确度。不过，如果应用依赖于某些框架提供的API，例如cordova.js的HTTP请求API，则在引入框架脚本之后再添加本探针的安装代码。 123456789101112&lt;script&gt; var _yyy = _yyy || []; (function() &#123; _yyy.push([metric1, literal]); _yyy.push([metric2, function]); // 可添加更多监控项或配置项 // ... &#125;)();&lt;/script&gt;&lt;!-- 如果是直接下载并安装到内部环境的探针，需要将下面src属性值中的“https://yyy.yonyoucloud.com”替换为“&#123;your/path/&#125;”--&gt;&lt;!-- 如果使用“在线脚本”的方式，则不要删除src值中的“tid”和“appid”参数，否则SDK将不可用！--&gt;&lt;script src=&quot;https://yyy.yonyoucloud.com/yonyou-yyy.js?tid=***&amp;appid=***&quot;&gt;&lt;/script&gt; 自定义监控维度我们提供自定义监控指标的API接口，方便用户从多种维度进行分析。 以自定义监控用户为例，示例代码如下：12345678910&lt;script&gt; var _yyy = _yyy || []; (function() &#123; _yyy.push([&apos;userid&apos;, &#123;&#123;USER_ID&#125;&#125;]); var s = document.createElement(&quot;script&quot;); s.src = &quot;https://yyy.yonyoucloud.com/yonyou-yyy.js?tid=***&amp;appid=***&quot;; var t = document.getElementsByTagName(&quot;script&quot;)[0]; t.parentNode.insertBefore(s, t); &#125;)();&lt;/script&gt; 可以以任何模板语法或js语法获取用户ID信息，例如JSP语法：1_yyy.push([&apos;userid&apos;, &lt;%=user%&gt;]); 也可以是一个回调函数。例如： 12345_yyy.push([&apos;userid&apos;, function()&#123; var userid; // 获取用户ID的操作 return userid;&#125;]); 附:可配置的指标自定义的指标通过全局变量“_yyy”访问，运行时通过回调方式动态获取。回调可以为直接量，也可以是函数。“_yyy”是一个二维数组变量，使用方法如下：123_yyy.push([metric1, literal]);_yyy.push([metric2, function]);... 示例内容可参考上文第2小节（“需要自定义监控指标项时的引入方式”）。 系统内置支持的指标列表 字段 含义 userid 用户ID。当使用友户通登录时，该字段为友户通用户主键。 username 用户名称 org_code 组织机构代码 org_name 组织机构名称 dept_code 部门代码 dept_name 部门名称 domaincode 领域代码 domainname 领域名称 modulecode 模块编码 modulename 模块名称 menugrpcode 应用分类编码 menugrpname 应用分类名称 menucode 应用编码 menuname 应用名称 defn 用户自定义的指标，最多支持20个，其中n为数字1~20","categories":[],"tags":[{"name":"前端监控","slug":"前端监控","permalink":"http://youyunyin.com/tags/前端监控/"}]},{"title":"图表最终形态","slug":"图表最终形态","date":"2018-12-05T16:00:00.000Z","updated":"2019-01-19T08:20:09.872Z","comments":true,"path":"2018/12/06/图表最终形态/","link":"","permalink":"http://youyunyin.com/2018/12/06/图表最终形态/","excerpt":"","text":"图表最终形态常用的图表形态常用的网页图表的展示形态一般为不含数据的html，通过ajax请求数据展示；在服务端渲染的页面/应用有含数据html方式图表的客户端的下载方式有pdf、图片两种，导出为html基本没有，操作查看也不方便下面对几种图表形态试用场景和优劣进行一下简单分析 不含数据html 通过ajax请求数据，然后通过html和js进行页面的渲染和交互是现在页面的主要方式。页面中图表主要也是通过这种方式。 主要优点有： 1. 对开发友好。现在主流的前后端分离开发方式图表数据一般由后端提供，图表由前端进行开发，这种方式方便进行解 耦，只需要定义好接口格式，即可分别开发互不干扰。对于单页面应用匹配度也较好。 2. 比较灵活。相比数据嵌入页面的方式这种方式进行需求变更是代价更小，不涉及数据修改的地方只需要前端进行修改 即可。对接口进行代理等统一处理时更方便灵活。 3. 大部分情况下性能较好，这种方式页面各个部分文件都不是很大，而且页面固定可以充分利用浏览器缓存，多个请求 数据接口也可以充分利用浏览器多个链接并发请求的优势。但是请求过多也会影响页面性能 4. 方便接口和页面文件复用 缺点： 1. 首屏等对页面响应时间要求较高的场景下不太适合。请求html，js之后，重新发起数据请求也需要时间对于页面本身 不是很大对响应速度要去较高的首屏展示等场景下性能不是很好 2. 一些情况下需要处理下跨域问题 例如需要从不同地址服务请求数据时 3. 页面进行本地保存时再次打开基本不能正常显示。请求数据登录失效跨域请求实现等方面的限制 包含数据的html 优点： 1. 页面和数据不大时时性能好，甚至html中可以包含样式和数据，只请求html就可以显示 2. 没有请求跨域问题 3. 对于最近开始流行的服务端渲染SSR契合度更好（SSR对于解决单页应用首屏慢以及SEO问题有了质的提升） 4. 页面本地保存时，由于页面包含数据基本上打开保存页面没有问题 缺点： 1. 对于数据量比较大的页面，数据都放到html中会导致单个文件过大，增加页面加载时间 2. 需要再web端查询接口并将数据插入生成页面中，增加了复杂度和调试难度 3. 开发成本增加，不和服务端渲染搭配使用需要额外增加一个中间层处理数据页面中，和SSR一起使用时，需要另外熟悉 SSR的开发调试技术，SSR相比客户端的单页应用也没有那么成熟 pdf、图片 pdf和图片由于基本没有交与性，一般只有客户端下载或保存图表时采用这种形式，pdf、图片都可以比较方便的由html转换成对应的格式。pdf进行保存相对来说稍微正式一点，显示的文本可以复制，可以包含一些简单的交互和动画。但是动画和交互部分，大部分导出的插件不支持。图片保存更方便，文件大小也更小，但是图片里面的文字不能复制，动画和交互也没有 综合分析 对于页面中图表的形态，结合我们dataFace项目的整体架构来看，首先暂时没有考虑SSR的方式，然后数据查询接口都在云端，接口地址比较集中，使用http代理进行一些处理也比较方便，另一方面dataFace主要是图表的可视化展示，首屏展示时间的要求不是很高，而且主要时间在数据查询的方面。综合考虑页面中图表以不含数据html更加合适。 图表保存的形态。这部分我们现有是pdf方式，在服务端进行html到pdf的生成，然后客户端进行下载。对于新增dataFace项目，可以考虑pdf和图片都支持的方式，对于整个报告还以pdf的方式，可以考虑客户端页面转pdf的插件，整个报告一方面基本包含了文字，另一方面整个报告查看缩放pdf有更好的效果。对于单个的图表也可以提供图片的下载方式，一般的图表库都提供了生成图片的接口。对于导出成包含数据html方式，不推荐一方面不符合普通人保存习惯，而且需要单独进行开发适配。","categories":[{"name":"博客","slug":"博客","permalink":"http://youyunyin.com/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://youyunyin.com/tags/hexo/"},{"name":"分享","slug":"分享","permalink":"http://youyunyin.com/tags/分享/"},{"name":"图表","slug":"图表","permalink":"http://youyunyin.com/tags/图表/"},{"name":"保存","slug":"保存","permalink":"http://youyunyin.com/tags/保存/"}]},{"title":"web全栈技术图谱v1.1","slug":"web全栈技术图谱v1-1","date":"2018-11-23T16:00:00.000Z","updated":"2019-01-19T08:20:09.871Z","comments":true,"path":"2018/11/24/web全栈技术图谱v1-1/","link":"","permalink":"http://youyunyin.com/2018/11/24/web全栈技术图谱v1-1/","excerpt":"","text":"小版本升级","categories":[{"name":"web前端","slug":"web前端","permalink":"http://youyunyin.com/categories/web前端/"}],"tags":[{"name":"技术图谱","slug":"技术图谱","permalink":"http://youyunyin.com/tags/技术图谱/"}]},{"title":"ReactiveX 的理念和特点","slug":"ReactiveX-的理念和特点","date":"2018-11-12T16:00:00.000Z","updated":"2019-01-19T08:20:09.869Z","comments":true,"path":"2018/11/13/ReactiveX-的理念和特点/","link":"","permalink":"http://youyunyin.com/2018/11/13/ReactiveX-的理念和特点/","excerpt":"","text":"ReactiveX是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流，Rx库支持.NET、JavaScript和C++，Rx近几年越来越流行了，现在已经支持几乎全部的流行编程语言了，Rx的大部分语言库由ReactiveX这个组织负责维护，比较流行的有RxJava/RxJS/Rx.NET，社区网站是http://reactivex.io/ 什么是ReactiveX微软给的定义是，Rx是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序，使用Rx，开发者可以用Observables表示异步数据流，用LINQ操作符查询异步数据流， 用Schedulers参数化异步数据流的并发处理，Rx可以这样定义：Rx = Observables + LINQ + Schedulers。 ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。 ReactiveX的应用很多公司都在使用ReactiveX，例如Microsoft、Netflix、Github、Trello、SoundCloud。 ReactiveX宣言ReactiveX不仅仅是一个编程接口，它是一种编程思想的突破，它影响了许多其它的程序库和框架以及编程语言。 使用观察者模式 创建：Rx可以方便的创建事件流和数据流 组合：Rx使用查询式的操作符组合和变换数据流 监听：Rx可以订阅任何可观察的数据流并执行操作 简化代码 函数式风格：对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态 简化代码：Rx的操作符通通常可以将复杂的难题简化为很少的几行代码 异步错误处理：传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制 轻松使用并发：Rx的Observables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题 使用Observable的优势Rx扩展了观察者模式用于支持数据和事件序列，添加了一些操作符，它让你可以声明式的组合这些序列，而无需关注底层的实现：如线程、同步、线程安全、并发数据结构和非阻塞IO。 Observable通过使用最佳的方式访问异步数据序列填补了这个间隙 单个数据 多个数据 同步 T getData() Iterable getData() 异步 Future getData() Observable getData() Rx的Observable模型让你可以像使用集合数据一样操作异步事件流，对异步事件流使用各种简单、可组合的操作。 Observable可组合对于单层的异步操作来说，Java中Future对象的处理方式是非常简单有效的，但是一旦涉及到嵌套，它们就开始变得异常繁琐和复杂。使用Future很难很好的组合带条件的异步执行流程（考虑到运行时各种潜在的问题，甚至可以说是不可能的），当然，要想实现还是可以做到的，但是非常困难，或许你可以用Future.get()，但这样做，异步执行的优势就完全没有了。从另一方面说，Rx的Observable一开始就是为组合异步数据流准备的。 Observable更灵活Rx的Observable不仅支持处理单独的标量值（就像Future可以做的），也支持数据序列，甚至是无穷的数据流。Observable是一个抽象概念，适用于任何场景。Observable拥有它的近亲Iterable的全部优雅与灵活。 Observable是异步的双向push，Iterable是同步的单向pull，对比： 事件 Iterable(pull) Observable(push) 获取数据 T next() onNext(T) 异常处理 throws Exception onError(Exception) 任务完成 !hasNext() onCompleted() Observable无偏见Rx对于对于并发性或异步性没有任何特殊的偏好，Observable可以用任何方式实现，线程池、事件循环、非阻塞IO、Actor模式，任何满足你的需求的，你擅长或偏好的方式都可以。无论你选择怎样实现它，无论底层实现是阻塞的还是非阻塞的，客户端代码将所有与Observable的交互都当做是异步的。 Observable是如何实现的？1public Observable&lt;data&gt; getData(); 它能与调用者在同一线程同步执行吗？ 它能异步地在单独的线程执行吗？ 它会将工作分发到多个线程，返回数据的顺序是任意的吗？ 它使用Actor模式而不是线程池吗？ 它使用NIO和事件循环执行异步网络访问吗？ 它使用事件循环将工作线程从回调线程分离出来吗？ 从Observer的视角看，这些都无所谓，重要的是：使用Rx，你可以改变你的观念，你可以在完全不影响Observable程序库使用者的情况下，彻底的改变Observable的底层实现。 使用回调存在很多问题回调在不阻塞任何事情的情况下，解决了Future.get()过早阻塞的问题。由于响应结果一旦就绪Callback就会被调用，它们天生就是高效率的。不过，就像使用Future一样，对于单层的异步执行来说，回调很容易使用，对于嵌套的异步组合，它们显得非常笨拙。 Rx是一个多语言的实现Rx在大量的编程语言中都有实现，并尊重实现语言的风格，而且更多的实现正在飞速增加。 响应式编程Rx提供了一系列的操作符，你可以使用它们来过滤(filter)、选择(select)、变换(transform)、结合(combine)和组合(compose)多个Observable，这些操作符让执行和复合变得非常高效。 你可以把Observable当做Iterable的推送方式的等价物，使用Iterable，消费者从生产者那拉取数据，线程阻塞直至数据准备好。使用Observable，在数据准备好时，生产者将数据推送给消费者。数据可以同步或异步的到达，这种方式更灵活。 下面的例子展示了相似的高阶函数在Iterable和Observable上的应用123456789// Iterable getDataFromLocalMemory() .skip(10) .take(5) .map(&#123; s -&gt; return s + &quot; transformed&quot; &#125;) .forEach(&#123; println &quot;next =&gt; &quot; + it &#125;) // Observable getDataFromNetwork() .skip(10) .take(5) .map(&#123; s -&gt; return s + &quot; transformed&quot; &#125;) .subscribe(&#123; println &quot;onNext =&gt; &quot; + it &#125;) Observable类型给GOF的观察者模式添加了两种缺少的语义，这样就和Iterable类型中可用的操作一致了： 生产者可以发信号给消费者，通知它没有更多数据可用了（对于Iterable，一个for循环正常完成表示没有数据了；对于Observable，就是调用观察者的onCompleted方法） 生产者可以发信号给消费者，通知它遇到了一个错误（对于Iterable，迭代过程中发生错误会抛出异常；对于Observable，就是调用观察者(Observer)的onError方法） 有了这两种功能，Rx就能使Observable与Iterable保持一致了，唯一的不同是数据流的方向。任何对Iterable的操作，你都可以对Observable使用。 名词定义这里给出一些名词的翻译 Reactive 直译为反应性的，有活性的，根据上下文一般反以为反应式，响应式 Iterable 可迭代对象，支持以迭代器的形式遍历，许多语言中都存在这个概念 Observable 可观察对象，在Rx中定义为更强大的Iterable，在观察者模式中是被观察的对象，一旦数据产生或发生变化，会通过某种方式通知观察者或订阅者 Observer 观察者对象，监听Observable发射的数据并做出响应，Subscriber是它的一个特殊实现 emit 直译为发射，发布，发出，含义是Observable在数据产生或变化时发送通知给Observer，调用Observer对应的方法，文章里一律译为发射 items 直译为项目，条目，在Rx里是指Observable发射的数据项，文章里一律译为数据，数据项","categories":[{"name":"笔记","slug":"笔记","permalink":"http://youyunyin.com/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://youyunyin.com/tags/笔记/"}]},{"title":"图表分享授权方式","slug":"图表分享授权方式","date":"2018-11-12T16:00:00.000Z","updated":"2019-01-19T08:20:09.872Z","comments":true,"path":"2018/11/13/图表分享授权方式/","link":"","permalink":"http://youyunyin.com/2018/11/13/图表分享授权方式/","excerpt":"","text":"图表分享授权方式网页上的分享一般都提供公开和私有两种分享方式。 公开分享不需要鉴权，只要有URL都可以打开查看。 私有分享常见的有两种鉴权方式 通过密码鉴权 打开页面后输入密码才能看到内容。例如百度网盘分享功能、网易有数的私有分享 通过token鉴权，通过HMAC算法，，客户端通过以token为key把一些变化的数据（通常是时间戳+一部分传递的数据）按照标准的HAMC算法，以指定的加密算法（SHA256、SHA-3等）计算出一个签名，在服务端通过HMAC算法验证签名是否正确来进行鉴权 公开分享公开分享由于有URL都可以查看。查看、传播或者进行嵌入的时候比较方便，但是没有鉴权，比较适合演示数据等公开的分享。 密码鉴权的私有分享密码鉴权的私有分享安全性比较适中，查看需要输入密码稍微麻烦点，进行传播比较方便，适合一定范围的分享。进行页面嵌入时麻烦一点，需要引入token进行免密登录。比较适合整个页面查看的时候，但是对于我们来说接入友互通之后本身具有这种功能。 token鉴权的私有分享token鉴权的私有分享安全性比较最高，适合页面嵌入，通过部署接口计算签名，获取签名后添加到嵌入页面URL参数中。一般来说验证具有瞬时性，即认证只在当时有效，不适合通过URL直接分享页面查看的情况。 HMAC简介在密码术中，HMAC（有时扩展为密钥散列消息认证码或基于散列的消息认证码）是涉及加密散列函数和秘密加密密钥的特定类型的消息认证码（MAC）。它可以用于同时验证数据完整性和认证一个的消息。任何加密哈希函数，例如SHA256或SHA-3，可用于计算HMAC; 得到的MAC算法称为HMAC-X，其中X是使用的散列函数（例如HMAC-SHA256或HMAC-SHA3）。HMAC的加密强度取决于底层散列函数的加密强度，散列输出的大小以及密钥的大小和质量。 HMAC使用两次哈希计算。秘密密钥首先用于导出两个密钥 - 内部和外部。算法的第一遍产生从消息和内部密钥派生的内部哈希。第二遍产生从内部哈希结果和外部密钥导出的最终HMAC代码。因此，该算法提供了对更好免疫长度扩展攻击。 HMAC不加密消息。相反，消息（加密与否）必须与HMAC哈希一起发送。具有秘密密钥的各方将自己再次散列消息，并且如果它是真实的，则接收的和计算的散列将匹配。 认证流程 先由客户端向服务器发出一个验证请求。 服务器接到此请求后生成一个随机数并通过网络传输给客户端。 客户端将收到的随机数提供给ePass，由ePass使用该随机数与存储在ePass中的密钥进行HMAC-MD5运算并得到一个结果作为认证证据传给服务器（此为响应）。 与此同时，服务器也使用该随机数与存储在服务器数据库中的该客户密钥进行HMAC-MD5运算，如果服务器的运算结果与客户端传回的响应结果相同，则认为客户端是一个合法用户 实际实现中前三部可以合为一步，随机数由时间戳代替，通过token（密钥）把参数和时间戳一起进行HASH算法计算的散列值发送给服务端，服务端进行验证。 总结综合考虑对于私有分享的图表的鉴权方式以token鉴权方式比较适合。页面分享查看这方面的鉴权友互通可以提供。图表嵌入的通过token方式进行鉴权，安全性高，实现起来也不麻烦，大部分现在编程语言也有提供了相关的工具方法，也有成熟的案例。 参考链接 网易有数分享功能介绍文档https://youdata.163.com/index/manual/o/5Share_your_analysis_results/4sharelink.html DataV分享功能介绍博客 https://yq.aliyun.com/articles/498033 HMAC介绍 https://en.wikipedia.org/wiki/HMAC JavaScript library of crypto standards https://www.npmjs.com/package/crypto-js nodejs crypto http://nodejs.cn/api/crypto.html#crypto_crypto_createhmac_algorithm_key_options java javax.crypto https://docs.oracle.com/javase/7/docs/api/javax/crypto/package-summary.html C# System.Security.Cryptographyhttps://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha256?view=netframework-4.7.2","categories":[{"name":"博客","slug":"博客","permalink":"http://youyunyin.com/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://youyunyin.com/tags/hexo/"},{"name":"分享","slug":"分享","permalink":"http://youyunyin.com/tags/分享/"},{"name":"授权方式","slug":"授权方式","permalink":"http://youyunyin.com/tags/授权方式/"}]},{"title":"页面嵌入方式对比分析","slug":"页面嵌入方式对比分析","date":"2018-11-01T16:00:00.000Z","updated":"2019-01-19T08:20:09.879Z","comments":true,"path":"2018/11/02/页面嵌入方式对比分析/","link":"","permalink":"http://youyunyin.com/2018/11/02/页面嵌入方式对比分析/","excerpt":"","text":"页面嵌入方式常用的几种页面嵌入方式 使用iframe 嵌入js代码 其他 Flash、ActiveX控件（技术老旧、不适用H5）、$.load等嵌入html方式（只适用与html，不适用与canvas图表、样式也会相互影响） iframe嵌入iframe嵌入是目前使用很广泛的一种嵌入方案 实现过程 iframe是HTML标准中用来嵌入页面的元素，嵌入实现过程比较简单，将iframe的src属性设置为需要嵌入的URL地址即可。然后和普通页面一样参数通过URL参数进行传递可以进行登录鉴权等访问控制。 嵌入部分与主页面通信 对于支持H5的现代浏览器，可以使用PostMessage接口通信，HTML5新增的window.postMessage, 是一种安全的,基于事件的消息API. 对于老旧浏览器，有很多种方法创建与父页面同源的ifame、window.name、修改URL中hash部分等。 不需要兼容老旧浏览器时，直接使用postMessage API就可以，需要兼容老旧浏览器时可以使用easyXDM，easyXDM是一个经过充分测试的JavaScript库，easyXDM集成了现有的多种跨域解决方案，针对不同浏览器可以适配最合适的方案，简化了跨域iframe之间的通信,并已经解决了所有的痛点。 优缺点 优势: 浏览器直接打开页面基本一致，不需要进行额外开发 安全, 主页面和iframe的环境是隔离的互相不能直接访问，不存在脚本冲突，样式影响问题 获取云端数据不存在跨域访问 劣势: iframe标签性能消耗较大，数量大于一定数量会造成页面卡顿 跨域iframe通信传递数据量较大时性能损失较大（数据传递时是复制） 嵌入js代码嵌入js代码，类似于JQuery插件，使用时通过token等取出图表数据等信息，在指定的DOM元素内绘制图表 主要分为两种 在服务端生成js代码 服务端根据请求查询出数据，将数据和图表组件绘制部分代码整合到一起返回，浏览器执行js脚本代码,绘制图表 直接引入静态js脚本 图表组件绘制交互部分代码作为静态代码引入，根据参数查询数据绘制图表 两种方案对比: 在服务端生成js代码,所有的代码和数据都包含在生成的js文件中,不需要做额外的请求,适用于数据量较小的时候.大部分情况下第二种方案实现更加灵活. 与iframe相比优缺点 优点： 不存在多个iframe的性能问题，多个图表可以公用一个图表绘制代码。 可以直接使用主页面的数据 缺点： 脚本冲突 如果主页面的也用了相同的库会不会脚本冲突，例如主页面也使用了vue开发（待验证） svg绘图时可能的样式影响 请求数据跨域问题 总结对于嵌入方式的选择一部分取决于准备以何种方式的嵌入。 以设计好的一个报告作为一个整体的嵌入，采用iframe方式会方便些，可以直接用分享页面一致的展示逻辑基本不需要修改，一个页面也很少嵌入很多的报告，这样iframe性能问题也不会成为瓶颈。 以单个图表作文嵌入的基本单位那么大部分页面都会嵌入很多，这样使用嵌入js代码会更合适些。","categories":[{"name":"博客","slug":"博客","permalink":"http://youyunyin.com/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://youyunyin.com/tags/hexo/"},{"name":"iframe","slug":"iframe","permalink":"http://youyunyin.com/tags/iframe/"},{"name":"页面嵌入","slug":"页面嵌入","permalink":"http://youyunyin.com/tags/页面嵌入/"}]},{"title":"web语义化","slug":"web语义化","date":"2018-10-30T16:00:00.000Z","updated":"2019-01-19T08:20:09.871Z","comments":true,"path":"2018/10/31/web语义化/","link":"","permalink":"http://youyunyin.com/2018/10/31/web语义化/","excerpt":"","text":"定义wiki(维基百科需要翻墙)的定义：语义化是前端开发里面的一个专用术语，其优点在于标签语义化有助于构架良好的html结构，有利于搜索引擎的建立索引、抓取；另外，亦有利于页面在不同的设备上显示尽可能相同；此外，亦有利于构建清晰的机构，有利于团队的开发、维护。 所以在html5中w3c引入了很多的标签：article、footer、header、nav、section等 一些标签语义： 标签 语义 h1~h6 标题 th table的header p 段落 ul 无序列表 ol 排序列表 dl definition list，定义列表 dt definition title，定义名称 dd definition description定义描述 em emphasized，局部强调,段落内强调 strong 更强烈的强调，全文强调 核心点便于机器识别html页面中的内容通常在\b开发前端过程我们最常用的标签就是div，然后用css来控制样式，各种组件效果都可以做出来，比如table，list,nav等。通常这些对于开发来说是比较容易理解，但是对于机器爬虫就很难快速识别页面中的内容，比如哪些是你的联系方式，哪些是你的文章区域，哪些是你的导航等。 此时如果有效的通过标签对内容尽可能的划分开，比如用footer标签来写copyright，爬虫就会很容知道这是网页的底部，进而很快的抓取到copyright等相关内容等。又比如用nav标签来定义导航块，爬虫根据标签就能很快获取\b网页的主要内容 便于其他研发人员快速读懂页面内容使用div的时候为了区分div中的内容通常的做法是定义id或者name属性，这样也能达到使用语义标签的效果，但是一旦div非常多，命名不规范的时候很容易造成混乱，对后续维护人员造成很大困难。 合理的使用标签能使得代码易读。当然标签只是一种手段，更重要的还是要有语义化的思想，最终的目的就是让维护人员快速读懂页面内容 通常来说，语义化好的页面，代码量会比较少，html结构清晰，有利于维护代码和添加样式 如何做判断网页标签语义化是否良好的一个简单方法是：去掉样式，看网页结构是否组织良好有序，是否仍然有好的可读性。语义良好的网页去掉样式后结构仍然是比较清晰的。尤其是在图片较少的网页中。 实例对如下内容格式化： 方案一12345&lt;div class=\"main\"&gt; &lt;div class=\"h2\"&gt;标签的语义&lt;a href=\"#\"&gt;更多&lt;/a&gt;&lt;/div&gt; &lt;div class=\"p\"&gt;段落1内容&lt;span class=\"strong\"&gt;强调内容&lt;/span&gt;&lt;/div&gt; &lt;div class=\"p\"&gt;段落2内容&lt;/div&gt;&lt;/div&gt; 上述代码添加CSS样式可以达到效果，但用的只是向div,span这样的无语义标签，我们从标签上看不出结构这样显然是不行的，我们需要用代码清晰表现出：“哪是标题”，“哪是内容” 方案二12345&lt;div class=\"main\"&gt; &lt;h2&gt;标签的语义 &lt;a href=\"#\"&gt;更多&lt;/a&gt;&lt;/h2&gt; &lt;p&gt;段落一的各种内容.....&lt;strong&gt;强调的内容&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;段落二的内容。。。段落二的内容。。。&lt;/p&gt;&lt;/div&gt; 方案二比方案一大有改进，从标签可以分清哪是标题哪是内容，也能看到哪被强调，但仔细看有a链接在h2标签中，虽然它们是在同一行，但a链接并不是属于标题！而且还是有无语义标签 方案三12345678910&lt;main&gt; &lt;header class=\"title\"&gt; &lt;h2&gt;标签的语义化&lt;/h2&gt; &lt;a href=\"#\"&gt;更多&lt;/a&gt; &lt;/header&gt; &lt;article class=\"content\"&gt; &lt;p&gt;段落一的各种内容.....&lt;strong&gt;强调的内容&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;段落二的内容。。。&lt;/p&gt; &lt;/article&gt;&lt;/main&gt; 方案三又有一些进步，利用HTML5定义的新标签是语义化更加完美，写到这里基本上也就可以了，但其实我们还可以利用ARIA(无障碍网页倡议)更加使代码完美。更加具有可读性。 方案四12345678910&lt;main role=\"main\"&gt; &lt;header class=\"title\" role=\"heading\"&gt; &lt;h2&gt;标签的语义化&lt;/h2&gt; &lt;a href=\"#\"&gt;更多&lt;/a&gt; &lt;/header&gt; &lt;article class=\"content\" role=\"contentinfo\"&gt; &lt;p&gt;段落一的各种内容.....&lt;strong&gt;强调的内容&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;段落二的内容。。。&lt;/p&gt; &lt;/article&gt;&lt;/main&gt; 现在可以看到标签中多了一些role属性，那是ARIA中定义的地标角色定义它们可以使屏幕阅读器更好的工作。当然并不是使用div这些标签就是不重视语义化，有些时候因为样式的需求必须使用这些无语义标签，这时我们就应该大胆使用它们。但能少用尽量少用。 参考 https://zh.wikipedia.org/wiki/%E8%AF%AD%E4%B9%89%E5%8C%96http://www.w3school.com.cn/html5https://www.cnblogs.com/p2227/p/3586725.htmlhttps://blog.csdn.net/hui1845/article/details/54955251https://developer.mozilla.org/en-US/docs/Web/Accessibility/An_overview_of_accessible_web_applications_and_widgets#ARIA","categories":[{"name":"web前端","slug":"web前端","permalink":"http://youyunyin.com/categories/web前端/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://youyunyin.com/tags/web前端/"}]},{"title":"ARIA无障碍网页倡议","slug":"ARIA无障碍网页倡议","date":"2018-10-30T16:00:00.000Z","updated":"2019-01-19T08:20:09.868Z","comments":true,"path":"2018/10/31/ARIA无障碍网页倡议/","link":"","permalink":"http://youyunyin.com/2018/10/31/ARIA无障碍网页倡议/","excerpt":"","text":"ARIA是什么？ARIA是“Accessible Rich Internet Applications ”的缩写。它是W3C的Web无障碍推进组织(Web Accessibility Initiative / WAI)在2014年3月20日发布的可访问富互联网应用实现指南。 WAI-ARIA是一个为残疾人士等提供无障碍访问动态、可交互Web内容的技术规范。在WAI-ARIA概述中对WAI-ARIA及其他支持文档进行了介绍。 要点 ARIA是W3C的一个独立规范，帮助Web应用程序和Web页面变得更具可访问性 ARIA主要是为了提升网页的可用性，网页对残疾人士的无障碍化 HTML5已经开始使用ARIA，并且W3C发布的很多其他标准也开始使用ARIA ARIA 是对 HTML 语义化的补充。它具备比现有的 HTML 元素和属性更完善的表达能力，并让你页面中元素的关系和含义更明确 ARIA 规范为浏览器和解析 HTML 文档的辅助性技术提供了一种可以让人们以多种方式访问和使用 Web 的标准方法 如何使用ARIA?应用于HTML的ARIA有两部分组成：role（角色）和带aria-前缀的属性，其作用： role(角色)标识了一个元素的作用 aria-属性描述了与之有关的事物（特征）及其是什么样的（状态） 参考 https://developer.mozilla.org/en-US/docs/Web/Accessibility/An_overview_of_accessible_web_applications_and_widgets#ARIAhttps://w3c.github.io/using-aria/http://www.w3cplus.com/wai-aria/wai-aria.html","categories":[{"name":"web前端","slug":"web前端","permalink":"http://youyunyin.com/categories/web前端/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://youyunyin.com/tags/web前端/"}]},{"title":"敏捷开发方法(四) 用户故事","slug":"敏捷开发方法-4-用户故事","date":"2018-10-28T16:00:00.000Z","updated":"2019-01-19T08:20:09.874Z","comments":true,"path":"2018/10/29/敏捷开发方法-4-用户故事/","link":"","permalink":"http://youyunyin.com/2018/10/29/敏捷开发方法-4-用户故事/","excerpt":"","text":"目录 概述 概念 实践核心店 用户故事模板 用户故事特征 用户故事三属性 优秀用户故事特征-INVEST原则 建立用户角色模型 用户故事场景 概念 场景类型 场景描述方法 验收标准 用户故事分级拆分 拆分原则 用户故事的大小 用户故事的分级 用户故事拆分 用户故事优先级 用户故事优先级排序介绍 用户故事优先级排序放法 Kano模型 相对权重法 概述概念 用户故事描述了对用户、系统或软件购买者有价值的功能 用户故事描述包含三个要素：角色、活动以及商业价值 描述方式为：作为XXX（用户角色）能够XXX（动作），以便于XXX（目的） 实践核心点 用户故事特性 用户角色建模 用户故事场景 用户故事验收标准 用户故事等级&amp;拆分 用户故事优先级 用户故事模板作为一个用户故事，必须包含如下的内容： 主题：采用三段论的方式进行用户故事描述。 描述：对故事的详细描述： 故事场景 业务流程 验收标准 优先级 估算值 用户故事特征用户故事三个属性用户故事描述了对用户、系统或软件购买者有价值的功能。其包括： 描述：总体描述，用来做计划和行为提示，用户故事描述包含三个要素：角色、活动以及商业价值 描述方式为：作为XXX（用户角色）能够XXX（动作），以便于XXX（目的）其中： 用户角色：谁要使用这个功能，在本指南中可以采用用户建模中的角色； 活动：需要完成什么样的功能； 商业价值：为什么需要这个功能，这个功能带来什么样的价值。 有关故事的具体化细节: 故事相关活动的细化说明，主要包含的内容. 在这个故事中，每个角色需要参与的工作（活动）及实现的结果； 在这个故事中，每个角色的工作流程； 每个工作流节点的具体工作内容及具体业务控制逻辑要求和逻辑条件。 包括在故事在团队讨论中内容形成的注释。 验收标准：用于表达和明确故事细节且可用于确定故事何时完成，用于明确团队完成故事的标准。 提示:用户故事要使用用户可以接受的业务语言来描述故事，不能够使用技术语言来描述。用户故事的质量是后续工作顺利完成的基础，因此尽可能保证用户故事的质量，不要因为用户故事的不清晰使得在开发中过多的投入到故事论述中，导致开发结果没有完成。 优秀用户故事特征-INVEST原则 I – Independent，独立性，可独立交付给客户：要尽可能的让一个用户故事独立于其他的用户故事。用户故事之间的依赖使得制定计划，确定优先级，工作量估算都变得很困难。通常我们可以通过组合用户故事和分解用户故事来减少依赖性。 N – Negotiable，可协商性，便于与客户交流：一个用户故事的内容要是可以协商的，用户故事不是合同。一个用户故事卡片上只是对用户故事的一个简短的描述，不包括太多的细节。具体的细节在沟通阶段产出。一个用户故事卡带有了太多的细节，实际上限制了和用户的沟通。 V - Valuable ，价值性，对客户有价值：每个故事必须对客户具有价值（无论是用户还是购买方）。一个让用户故事有价值的好方法是让客户来写下它们。一旦一个客户意识到这是一个用户故事并不是一个契约而且可以进行协商的时候，他们将非常乐意写下故事。 E - Estimable ，估算性，能估计出工作量：开发团队需要去估计一个用户故事以便确定优先级，工作量，安排计划。但是让开发者难以估计故事的问题来自：对于领域知识的缺乏（这种情况下需要更多的沟通），或者故事太大了（这时需要把故事切分成小些的）。 S - Small ，短小：分解到最底层的用户故事粒度尽量小，至少在一个迭代中能完成，一个好的故事在工作量上要尽量短小，最好不要超过一个迭代周期的工作量,要确保的是在一个迭代中能够完成。用户故事越大，在安排计划，工作量估算等方面的风险就会越大。 T - Testable，可测试性:一个用户故事要是可以测试的，以便于确认它是可以完成的。如果一个用户故事不能够测试，那么你就无法知道它什么时候可以完成。一个不可测试的用户故事例子：软件应该是易于使用的。 建立用户角色模型建立用户角色模型即梳理用户角色:把客户和开发人员聚集到一个房间中，通过头脑风暴，列出初始的用户角色集合，然后整理最初的角色集合，通过整合角色和提炼角色，最终确定出使用软件的角色。 具体操作方法可以参考如下： 所有相关人员包括开发人员、需求人员、客户等均聚集在一起，通过头脑风暴首先列出原始的用户角色： 只需要在卡片中写出自己想到的角色，不需要讨论和评估； 将卡片读出来，粘贴到展示板中； 直到大家没有新的角色提出； 要注意列出的角色是产品实际使用用户。初步分类：将第一步形成的用户角色进行初步分类，形成角色集合： 将卡片进行初步分组，标明角色间的关系； 相同的进行重叠； 包含关系通过卡片的覆盖进行体现； 系统角色尽量是一个具体的人。整合角色： 去掉完全重合的卡片角色，讨论中可能会新增新的卡片； 丢弃对系统不重要的角色。提炼角色，建立角色卡片： 经过前期的讨论，已经对角色之间的关系有了基本的了解； 通过提炼的角色，描述角色特征，角色特征可以从如下几个方面进行考虑： 用户使用软件的频率； 用户在相关领域的知识水平； 用户使用软件和计算机的熟悉程度； 用户使用该软件的目标和特点，如用户特别关注便捷性、关注用户体验； 本软件对该用户有帮助的特征； 将特征形成用户角色特征卡片。 为了让角色更加完整，在用户故事后续重更加生动准确。可以进行如下两个角色的补充，根据产品实际情况进行，非必需。 虚拟角色：虚构出一个实际用户，阐述他的特点和可能使用的场景，该角色需要真正代表产品的目标客户，作为软件虚拟使用人员，可以配以名字、照片、相关信息描述，在项目中可以理解为是真实存在的。 极端角色：可以找到一些遗漏的故事，根据产品需要决定是否有必要； 用户故事场景概念定义：从用户的角度出发，描述了一组典型用户在典型工作环境下的典型需要、想法、工作习惯等，是指一个应用(通常就是你的那个产品)被使用的时候，用户“最可能的”所处场景。 用户故事场景的设计，主要从以下几个方面考虑： 对每一个场景，设计一个场景入口，就是描述场景如何开始 用户故事主要是描述典型用户在这个场景中所处的内部和外部环境（内部环境指心理因素等） 需要给场景划分优先级，并按优先级排序 用户场景有大有小，适度、平衡即可 用户和系统有成百上千种可能的交互情况，在写场景的时候要有针对性用户故事场景的特征： 场景的背景： 典型用户 用户的需求、迫切需要解决的问题 假设 行业背景等 场景：关于这个场景的文字描述：要列出这故事中出彩的地方, 例如：软件的哪些功能让用户特别满意? 逻辑和界面设计要注意哪些因素? 第一次使用的用户和多次使用的用户在体验上有何区别对待? 其他参考资料（工作规程、组织机构图、工作职责清单等）场景通常在限定的条件内而存在，场景包括时间、空间、设备支持、社交及用户情绪等多个方面，进行应用场景的判断和描述的时候，尽量把这些都考虑完整。 场景的类型 基于故事目标或者任务的场景：主要描述用户想做什么，不包含用户如何完成任务的任何信息。 精细化的场景:提供了更多的用户使用细节。这些细节能帮助团队更深入的理解用户特点。 全面的场景描述:场景和人物角色还可以结合起来，分类呈现不同类型的用户使用产品的原因，有什么样的需求，揭示出“什么样的人”在“什么样的场景”下会有“什么样的行为”。 测试场景:说明预期的用户是如何完成这个任务的所有路径和步骤，包括用户可能使用的主要的入口或者其他的入口，供观察人员和记录人员在测试中使用。而在测试后，可对比下你的预期过程和用户完成任务的真实过程。 场景描述方法场景描述中需要明确： 环境-人员-事情-产生的价值； 用户故事可以采用卡片、故事访谈链接、用户场景截图、故事板等方式表达故事的场景 验收标准验收标准：定义故事是否完成的标准，让团队和产品负责人对此达成一致 面向用户的价值设定验收标准，业务验收标准主要包含： PO或需求从业务的角度描述此功能的验收标准，在故事进入迭代计划之前该验收标准明确清晰； 按照用户的需要，产品Backlog条目完成； PO或需求在Sprint结束时接受或拒绝接受开发团队的工作成果，对每个演示的故事和主要缺陷，PO表示接受（符合预期和验收标准）或拒绝（不符合预期或不满足验收标准），并给予团队反馈或意见； PO或需求根据用户的价值确定功能优先级，并确认功能已经开发完成； PO确认已经达成产品的投资回报率(ROI); 用户故事分级拆分拆分原则 缩短完成用户故事的时间； 减少用户故事大小的差异性； 采用逐级分解细化方式，最终拆解为用户故事。 用户故事的大小用户故事的大小与完成时间不是成正比的，故事增加两倍，投入时间可能增加5倍；当前我们通过时间盒的方法控制用户故事的大小。目前我们的要求是：用户故事大小不能超过迭代周期。 史诗：通常为大一点的用户故事，通常分为两种 复合故事（compound story）：由多个小的故事组成； 复杂故事（complex story）：本身就很大且不容易分解的故事。 通常通过分层的方式体现，有些需要采用探针实验进行验证 用户故事的分级用户故事可以两个维度进行划分：一个是产品展现形式，一个是产品颗粒度。 产品展现形式分为以下三部分： 客户可见: 产品史诗、产品功能、产品增强，描述产品的卖点(展现给客户) 产品经理可见: 产品优化、产品约束、产品条件、产品性能等 开发团队可见三部分进行区分：产品缺陷，产品重构 产品颗粒度采用树形结构的形式进行细分，上级故事也可称为史诗级别的故事。 用户故事拆分主要是要从客户角度对用户故事进行划分，具体可以： 按照不同操作— 即根据动作对故事进行分解，添加、删除、修改、浏览等 按照数据—即根据数据边界进行分解，可以浏览产品名和介绍、可以浏览产品价格 按照特性—易用性、性能、兼容性、并发性等等 按照角色—从不同用户角度按照投入的人力 - 比如要完成信用卡支付(Visa, Master, AmericanExperess)，可以分成三个故事来实现 按照实现复杂程度、步骤—解为探针实验调研以及实现两部分进行分解； 按照流程: 即根据业务流程进行分段，明确输入输出 产品缺陷：分为两类，一类是客户发现的，需要展现给用户，一类是我们自己发现。 用户故事优先级用户故事优先级排序介绍PO负责排序Story，产品总监负责排序Eipc和拍板有争议的story，排列优先级时需要考虑下面几点： 大部分用户和客户对特定特性的渴望程度 小部分重要用户和客户对特定特性的渴望程度 故事之间的互补或依赖关系 用户故事优先级排序放法Kano模型我们根据用户需求重要性将需求分为三种类型：基本型需求&gt;期望性需求&gt;兴奋型需求，这三种需求根据绩效指标分类就是基本因素、绩效因素和激励因素。 需求类型 定义 不满足时 满足时 兴奋型需求 要求提供给顾客一些完全出乎意料的产品属性或服务行为，使顾客产生惊喜 当其特性不充足时，并且是无关紧要的特性，则顾客无所谓 当产品提供了这类需求中的服务时，顾客就会对，产品非常满意，从而提高顾客的忠诚度 基本型需求 顾客认为产品“必须有”的属性或功能 当其特性不充足（不满足顾客需求）时，顾客很不满意 当其特性充足（满足顾客需求）时，无所谓满意不满意，顾客充其量是满意 期望型需求 要求提供的产品或服务比较优秀，但并不是“必须”的产品属性或服务行为有些期望型需求连顾客都不太清楚，但是是他们希望得到的 当没有满意这些需求时，顾客就不满意 在市场调查中，顾客谈论的通常是期望型需求，期望型需求在产品中实现的越多，顾客就越满意 通过两个问题确定功能的分类： 关于产品中具有这项功能，用户会觉得怎样­——功能存在形式 关于产品中没有这项功能，用户又会觉得怎样——功能缺失形式 对每个问题采用五点度量方式进行问答 我希望这样 我预期就是这样 我没有意见 我可以忍受这样 我不希望这样 答案分类，得到每条需求的分类维护在维度内进行数字优先级排序多人问卷调查，提高准确性实施：通过excel进行。 相对权重法 考虑一项功能所带来的正面益处，和缺乏他所产生的负面影响。评估如果实现它所带来的收益、如果不实现它所会招致的惩罚。 同故事点估算一样，对收益和惩罚也是采用1-9的尺度进行相对度量。 提示： 优先级= 价值百分比/成本百分比 价值百分比= 功能价值/价值总和","categories":[{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/categories/研发管理/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://youyunyin.com/tags/笔记/"},{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/tags/研发管理/"}]},{"title":"敏捷开发方法(三) 看板 vs scrum","slug":"敏捷开发方法-3-scrum对比kanban","date":"2018-10-27T16:00:00.000Z","updated":"2019-01-19T08:20:09.873Z","comments":true,"path":"2018/10/28/敏捷开发方法-3-scrum对比kanban/","link":"","permalink":"http://youyunyin.com/2018/10/28/敏捷开发方法-3-scrum对比kanban/","excerpt":"","text":"Scrum 与 Kanban 对比&amp;选择","categories":[{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/categories/研发管理/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://youyunyin.com/tags/笔记/"},{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/tags/研发管理/"}]},{"title":"图表组件D3调研及和Echarts对比","slug":"D3调研以及和ECharts对比","date":"2018-10-27T16:00:00.000Z","updated":"2019-01-19T08:20:09.868Z","comments":true,"path":"2018/10/28/D3调研以及和ECharts对比/","link":"","permalink":"http://youyunyin.com/2018/10/28/D3调研以及和ECharts对比/","excerpt":"","text":"简介近年来，可视化越来越流行，许多门户网站、新闻、媒体都大量使用可视化技术，使得复杂的数据和文字变得十分容易理解，有一句谚语“一张图片价值于一千个字”，的确是名副其实。各种数据可视化工具也如井喷式地发展，D3，ECharts正是其中的佼佼者。 D3 的全称是（Data-DrivenDocuments），顾名思义是一个被数据驱动的文档。其实是对数据进行可视化的JavaScript库。D3将强大的可视化和交互技术与数据驱动的DOM操作方法相结合，能最大限度地使用现代浏览器的性能同时为设计可视化界面保留了最大的自由度。D3强调Web标准，所以无需将自己与专有框架联系起来。 官网：https://d3js.org/ GitHub：https://github.com/d3/d3 官方示例：https://github.com/d3/d3/wiki/Gallery D3示例demo网站：https://bl.ocks.org/ 、http://blockbuilder.org/search 插件：https://github.com/d3/d3-plugins ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC和移动设备上，兼容当前绝大部分浏览器，底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。ECharts提供完善的中文文档，能够快速通过配置实现支持的图表。 官网：http://echarts.baidu.com/index.html GitHub : https://github.com/apache/incubator-echarts 开发流程对于ECharts，hightchart这类经过进一步封装的可视化库开发流程 根据需求确定图表类型(例如折线d3.line) 查找所需图表类型配置和数据格式要求，按照要求进行配置项配置，转换数据到指定格式 在该类图表支持的动画、事件交互中选择需要的进行配置 对于D3 根据需求确定图表类型(例如折线d3.line) 把输入的原始数据转化成为标准的D3可接受的数据格式一般图像是对象数组 根据原始数据定义好x轴函数、y轴函数和定义好作图方式在SVG上，画出x轴y轴、根据原始数据结合x轴及y轴函数作线状图 再画出标题等细节的东西 给已经完成的图形添加动画效果和事件交互 （可参看demo网站中有没所需图的示例，插件中有没有所需图表动画的实现，可节省很多时间） 难易程度ECharts，hightchart这类可视化库，经过配置即可完成图表的绘制，D3要稍微麻烦一点。 使用D3绘图需要 熟悉SVG（canvas）作图、熟悉CSS D3.js提供了绘图中常用的计算工具函数，和方便操作SVG的方法（v4以后的D3也支持canvas，但不是所有的方法都支持），但是就SVG绘图的知识比较熟悉才能比较方便实现所需的效果。就像使用JQuery开发也需要一定的DOM熟练度一样。 D3的样式颜色和一大部分动画通过CSS来设置。 熟悉D3的API D3提供了很多可视化常用的计算方法和工具方法，熟悉之后才能事半功倍 学习D3.js的编程风格 D3的语法大部分是函数式编程，了解一下函数式编程的curry与compose思想，除getter基本都可以链式调用这点类似于jQuery，理解选择器绑定数据后Update，Enter 和 Exit 的用法，然后要学习D3的画图一般思路，就像前面的开发流程。 总结：D3和ECharts，hightchart这类可视化库相比属于可视化中较为基础的工具库，需要一定的可视化方面的基础才能比较快速开发出较复杂的图表，可以先尝试实现简单的图形，官网首页上面就大部分酷炫的在线Demo，难度较高可以先从demo网址找些简单点来实现 对比ECharts优劣对比D3和ECharts之前，先对比下两种浏览器图形渲染技术Canvas和SVG的主要区别，基本上所有的浏览器可视化第三方库都是基于这两种浏览器图形渲染技术实现的（WebGl虽然和2D的canvas没啥关系，广义上也算Canvas）： SVG Canvas 矢量图不依赖分辨率，放大不失真 位图依赖分辨率 基于XML支持DOM事件处理器，SVG中每个图形节点都是单独的DOM节点可以附加js事件 不支持事件处理器 如果要为细粒度的元素添加事件，就需要边缘检测算法，无疑增加了难度而且不一定能保证十分精确 适合带有大型渲染区域的应用（比如：地图（每个节点区域都比较大，节点不是很多）） 最适合图像密集型的应用比如游戏 能够方便的保存结果图像 复杂度高会减慢渲染速度（任何过度使用DOM的应用都快不了） 一旦图形绘制完成，就不会再得到浏览器的关注 如果位置或者大小变化整个区域都要重新绘制 可以使用CSS 文本渲染能力较强 文本渲染能力较弱 简单对比后： SVG比较适合 数据量不是很大，应用存在大量的用户交互场景。 Canvas比较适合事件交与较少，文本较少，或者数据量大画面刷新快的场景。 ECharts D3 Canvas为主4.0+也支持SVG SVG为主4.0+也支持Canvas 提供很多图表通过简单配置可以满足大部分需求 不能通过简单配置实现大部分图表 基本不可定制 自由度很大，基本可以自己绘制任何图表 提供完善中文文档，示例功能完善 提供完善英文文档，3.x版本中文文档比较完善，之后翻译的不完善，部分翻译可能需求查看英文方便理解，大部分示例需要完善才能使用，主要是参考价值 开发效率高，通过快速配置即可完成 大部分图表需要开发 大数据量性能较好 需要实现时手动优化 例如virtual DOM 提供基于WebGl的GL版实现3D图表 借助其他库来实现例如：three.js、glMatrix、Sylvester 对于ECharts支持的图表： 使用ECarts有较大的优势，开发效率高，动画、事件等实现也比较完善，正常情况下基本没有bug。 对于Echarts不支持的图表： 数据量不是特别大或者事件交互比较精细的场景采用D3 SVG来实现，可以先在官方示例和demo搜索有没有类似的图表实现。对于频繁的DOM操作十分消耗性能。对于用户体验的影响便是可能出现闪烁、卡顿等现象。可以参考前端界对于页面DOM卡顿的解决方案：Virtual DOM 技术。通过支持 Virtual Dom 技术的框架如Vue与 D3.js结合。使用D3来计算，Vue等Virtual DOM框架管理SVG节点和属性。 对于数据量比较大的场景，可以采用D3Canvas来实现，或者ZRender（ECharts使用的矢量图形库）来定制，这个需要比较熟悉Canvas绘图，而且需要注意性能的优化。 总结ECharts等提供的图表的确可以满足大部分的需求，遵循了数据可视化的一些经典范式，一切皆可配置。然而，每个不同的行业对于数据可视化都会有一些定制化的需求，希望能以一些带有行业特征的图表向使用者展示数据背后隐藏的秘密，但是ECharts这类图形库基本不可定制，而D3自由度度很大，基本可以自己绘制任何想要的图形，这类情况的需求可以使用D3进行二次开发，定制适合的图表，但是开发成本会稍高。因此，开发中要根据实际情况来判断。无论采用哪种方式开发都要做好二次封装，把实现的图表成可复用的组件。 相关文档：W3C SVG标准https://www.w3.org/Graphics/SVG/ 可缩放矢量图形（Scalable Vector Graphics，SVG)https://developer.mozilla.org/zh-CN/docs/Web/SVG W3C Canvas https://www.w3.org/TR/2dcontext/ MDNCanvas教程https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial WebGl简介 http://www.khronos.org/webgl/ MDN WebGl教程 https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API","categories":[{"name":"博客","slug":"博客","permalink":"http://youyunyin.com/categories/博客/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"http://youyunyin.com/tags/D3-js/"},{"name":"Echarts","slug":"Echarts","permalink":"http://youyunyin.com/tags/Echarts/"},{"name":"可视化","slug":"可视化","permalink":"http://youyunyin.com/tags/可视化/"}]},{"title":"自动化布局方案","slug":"自动化布局方案","date":"2018-10-27T16:00:00.000Z","updated":"2019-01-19T08:20:09.878Z","comments":true,"path":"2018/10/28/自动化布局方案/","link":"","permalink":"http://youyunyin.com/2018/10/28/自动化布局方案/","excerpt":"","text":"DataFace自动化布局方案 简介 市面上的布局方式基本分为两类：自由式布局（阿里DataV和网易有数使用，dataface已在前期工作中实现），自动化布局（百度Sugar使用）。它们各有特点。 自由式布局：自由程度高、简单明了，缺点是编辑工作量大，易用程度低。 自动化布局：在熟悉拖动规则后，编辑成本低，时间快。 本文主要介绍dataface自动化布局的策略规则以及算法实现。 2 方案优势 2.1基础功能 1. 组件的可拖拽行为 2. 组件不能重叠 2.2优势 在一般自动化布局的功能基础上更灵活和快速： 1. 支持插入功能 2. 支持各个组件位置的位置互换 3. 支持拖入模板布局 4. 支持操作时不影响其他已经编辑好的区域 2.3解决痛点 解决了百度Sugar自动化布局方案中的以下痛点： 1. 选择新的组件拖入面板时永远只能在末尾插入的问题 2. 组件只能进行相邻位置的互换，不相邻位置互换时导致大量组件顺序异常。 3. 组件不能进行插入动作 4. 删除某一个组件时会引起全局组件的位置混乱 5. 改变某一个组件大小变化时，可能会引起全局组件的位置混乱 6. 单个组件不能自由拖动到空白位置。 3技术解析 3.1Vue内部流程 3.2相关浏览器鼠标监听方法 //禁止原本拖拽行为 document.onselectstart = function(){ return false ;}; //鼠标左键按下 onmousedown //鼠标移动行为 onmousedown //鼠标抬起 onmousedown 3.3主要自定义方法 drag：拖拽某一个组件 dragDemo：从组件列表中选取组件拖拽进页面 dragBt：拖拽组件大小的按钮 focus：聚焦到当前选中的组件 canvasBg：画布大小拖拽 dragDelete:组件删除 3.4数据格式 3.4.1某一个组件：（文本组件例） vText1:{ type:&amp;quot;vText1&amp;quot;, name:&amp;#39;文字/单值&amp;#39;, css:{ backgroundColor: &amp;quot;#fff&amp;quot;, &amp;#39;border-radius&amp;#39;:&amp;quot;4px&amp;quot;, color:&amp;quot;#555&amp;quot;, fontSize:&amp;quot;14px&amp;quot;, left:&amp;quot;200px&amp;quot;, top:&amp;quot;100px&amp;quot;, &amp;#39;opacity&amp;#39;:&amp;#39;.5&amp;#39;, }, //坐标信息 info:{ &amp;#39;height&amp;#39;:10, &amp;#39;width&amp;#39;:3, &amp;#39;xy&amp;#39;:[0,0] }, data:{ type:&amp;#39;静态数据&amp;#39;, staticValue:&amp;#39;新的描述文字&amp;#39;, key:&amp;#39;text&amp;#39;, } }, 3.4.2画布中的全部组件 previewData:{ //画布中的组件数据 &amp;#39;data&amp;#39;:[], //全局数据 &amp;#39;global&amp;#39;:{ &amp;#39;css&amp;#39;:{ &amp;#39;canvasHeight&amp;#39;:&amp;#39;1080&amp;#39;, &amp;#39;canvasWidth&amp;#39;:&amp;#39;1200&amp;#39;, &amp;#39;adjust&amp;#39;:&amp;#39;scroll&amp;#39;, &amp;#39;bgColor&amp;#39;:&amp;#39;#f0f3f4&amp;#39;, } } }, 3.5算法流程 3.6坐标解析3.6.1二维数组表达画布： 用数组的方式表达才可以便于计算，整个画布暂分为横向12个单位，每个单位的代表宽度根据实际画布像素宽度得出。纵向以每10px代表一个基本单位。以宽高比为1200px\\*1080px的画布为例，那么横向操作以100px为一个最小变量，纵向操作每次以10px为一个最小变量。根据1200px\\*1080px的画布得到一个二维数组tArray[x][y]，x代表高度，长度为108，y代表宽度，长度为12。此时的x、y与一般的x、y轴坐标是相反的，目的是为了在二维数组的数据中直观反映真实的模块位置。画布左上角为起始点即tArray[0][0]。其中数组的值如果是empty，则表示该区域没有被占据。如果有值，那么值则可以理解为这个组件的id，通过id我们可以在上文提到的store.previewData中找到该组件的全部信息。 形成的二维数组如图（此时，画布中有id为0及1的两个组件） 3.6.2单个组件的坐标记录 组件数据的info属性记录该组件的坐标信息，info下共有三个属性，xy表示该组件的起始点坐标，width表示组件宽度，height表示高度。 3.6.3单个组件的最小宽度 组件宽度最小为一个基本单位，高度最小为5个基本单位，即50px。以免出现组件高度过低无法操作的问题。 4策略规则及算法逻辑 4.1从组件面板中拖出一个组件到画布（新组件插入） 4.1.1策略规则 普通思路:当画布为空时将新组件置于画布左上角（右图为输出结果）， 当画布已有组件，再判断鼠标落点… 策略规则：直接判断鼠标落点，只采用先左后上的规则，因为如果是先上后左，普通的布局顺序都是从上到下的，在页面过高时，新拖进来组件有可能不在当前可视区域。 场景1：若鼠标落点在已有组件上，则出现禁止操作，拖动失败。 场景2：若鼠标落点在空区域上 算法描述： 1. 先寻找鼠标落点左侧边界，获取空区域起点[x,y]的y值； 2. 再寻找鼠标上方边界，获取空区域数组起点[x,y]的x值； 3. 获得空区域起始点坐标后，再计算空区域的最大宽度和最大高度 4. 空区域的起点坐标即组件的起始点 5. 通过空区域的宽高与组件初始宽高比较，判断是否改变组件初始宽高。 6. 最终将组件放入画布 4.2画布中的组件拖动 策略规则：支持单个组件的上下左右的任意拖动，支持组件间位置的替换，原则上不影响无关组件的大小及位置，更不能超过画布的边界。 场景1：单个组件拖去空白区域，拖动路径未经过其他组件 算法描述： 1. 根据鼠标起点，及鼠标落点，计算出横向及纵向的移动距离 2. 移动的距离与原始起始点相加，获得新的起始点坐标，但是鼠标落点是空白区域，起始点的区域有可能不是空白 3. 若起始点为空白区域时，同时起始点与鼠标落点之前封闭区间为连续空白，将起始点作为空区域的起始点计算空区域最大宽度与高度 4. 若起始点不为空白区域或者起始点与鼠标落点之间的区域为非连续空白，则以鼠标落点，寻找上边界（遍历高度不超过组件高度），寻找左边界（遍历宽度不超过组件宽度），上边界与左边界的交点为新起始点，将其作为空区域的起始点计算空区域最大宽度与高度 5. 通过空区域的宽高与组件初始宽高比较，判断是否改变组件初始宽高。将组件移入空区域。 场景2：单个组件拖去了另一个组件（两个组件位置互换），拖动路径未途经其他组件 算法描述： 1.直接替换两个组件的坐标信息 场景3：拖动路径途经其他组件 算法描述： 1变量记录途径的组件id 2.每次途径新的组件时，通过变量替换相关信息，将新的组件赋值给变量。 3.下图，途径了两个组件，移动之后，途径的组件都不应该发生变化 4.3拖动改变组件大小 策略规则：支持单个组件的宽高的拖动，拖动范围横向为右边界，纵向不限。原则上不影响无关组件的大小及位置，更不能超过画布的边界。 场景1：拖动范围内都为空白区域 算法描述： 1. 正常计算拖动的大小，改变组件的大小。 场景2.1：横向右拖动有组件，在同一行 场景2.2：横向右拖动有组件，且不规则不在同一行 算法描述： 1. 根据拖动宽度依次填补空白区域，到达右侧边界停止。 2. 依次的相关组件会被从左边推动，会向右侧平移 3. 相对独立的区域，内部相对的位置不变动 4. 相对独立的区域会因为被从左边推动，会向右侧平移 场景3：横向左拖动有组件 算法描述： 1. 直接减少该组件的宽度。 场景4：纵向的向上向下拖动 算法描述： 1. 计算获取相对独立区域 2. 若该高度没有大于相对独立区域，则在该区域内进行增减 3. 若该高度是相对独立区域的边界，则应下方区域位置都会进行增减移动 4.4拖入布局模板（新增） 策略规则：支持拖入丰富的布局模板，再在布局模板中拖入组件，从而更简化流程。 算法描述： 1. 拖入的布局模板都以整行插入的形式 2. 可以理解布局模板是一种特殊的空白组件 3. 布局模板不支持单个拆分","categories":[{"name":"博客","slug":"博客","permalink":"http://youyunyin.com/categories/博客/"}],"tags":[{"name":"DataFace","slug":"DataFace","permalink":"http://youyunyin.com/tags/DataFace/"},{"name":"布局","slug":"布局","permalink":"http://youyunyin.com/tags/布局/"}]},{"title":"敏捷开发方法(二) 看板","slug":"敏捷开发方法-2-kanban","date":"2018-10-26T16:00:00.000Z","updated":"2019-01-19T08:20:09.873Z","comments":true,"path":"2018/10/27/敏捷开发方法-2-kanban/","link":"","permalink":"http://youyunyin.com/2018/10/27/敏捷开发方法-2-kanban/","excerpt":"","text":"概念重点关注 关注可视化和管理流程 不依赖迭代，提倡持续连续工作流，使得团队保持专注 核心概念四个主要原则： 从实际开始；专注增量和渐进性改进 尊重现有方法和角色，培养组织各级领导力 六个核心实践： 可视化工作流程 在制品数量（WIP） 工作项流动 明确规则 确保反馈 建立看板可视化工作流 绘制价值流图：依据团队实际流程，可视化全过程，并通过与上下游协作部门达成共识，进行价值流图向上下游的扩展； 设置输入和输出边界：在设计看板系统的时候要尽早对在制品控制的边界做出决策，对受控范围内的自身团队的工作提供透明度； 分割进行中和已完成，添加必要的缓冲区或等待队列：缓冲或等待队列增大了系统的在制品值，他们将导致前置时间拉长；但是缓冲和队列可以使工作流动变得平滑； 可视化工作项： 可视化价值：上图中的每一个卡片代表一个价值项，它们可以是功能特征、技术任务、缺陷、重构、环境相关等等以开发为中心的一切工作类型； 可视化价值流动：任务卡片所在的列，表示其所处的阶段，价值流是价值项从左至右的流动过程，是信息的产出过程，也是价值增加的过程； 可视化问题及阻碍：价值流动可能会被阻碍，标识阻碍因素（例如用红色卡片对问题和阻碍因素可视化）并推动其解决，促进价值流动； 可视化队列/瓶颈：最终限制系统端到端流量的是系统瓶颈处的流量，必须从解决瓶颈问题开始； 显示化规则团队看板系统建立之初，一项有价值的实践必不可少，显示化团队工作的规范，规则。显示化流程规则，是指明确定义和沟通团队所遵循的流程规则，从而让团队和利益干系人就工作协议达成一致。 价值项的“流转规则”是看板系统中最典型流程规则，它定义了一个价值项从一个阶段进入下一阶段所必须达到的标准。 图中，给出了某团队其中价值流转规则的实例，例如流程规则2定义了从UE设计阶段进入待开发开发阶段所必须达到的条件。“流转规则”的显式化，让质量内建于各个阶段——这与精益制造中内建质量的思想是一致的。某些团队使用DoD（定义完成标准）做流转规则不失为定义“流程规则”的简便方法，但应该注意的是流程规则可能需要随着团队和流程改进调整。 除“流转规则”外，其它重要的规则也可以或者需要被显式化，如，团队的工作纪律，协作规则、优先级的定义规则，缺陷处理策略，输入节奏，交付节奏等，我们称之为其他规则。 “流程规则”和“其他规则”可以让研发相关活动有序保质的完成。 初始化在制品限额(WIP） 在制品限额: 明确限制流程中每个状态上最多同时进行的任务数，是看板方法中的一个核心机制，如下图所示，列标题上面的数字标识了该阶段允许的在制品的最大数目； 设置在制品限额的目的： 优化价值流动：限制在制品数量，减少了价值项在阶段间的排队等待，缩短了价值从进入系统到交付的时间，加速了端到端的价值流动； 暴露问题：限制在制品数量，让过去被隐藏的问题，如团队协作不良、需求定义错误、开发环境低效、资源分配不均衡等得以显现； 初始化在制品限额： 工作任务的在制品限额应该按照每个人、每个开发结对或每个协同工作的小团队的平均工作项数量来设置，一般而言，限额数值应该控制在1~3人（/结对/团队）范围内比较合适，业内推荐限额设置公式为 2n-1（n为人数/结对数/小团队数）； 可以将工作任务一栏和完成队列归在一起，合并计算在制品限额；缓冲区的限额越小越好，但是其大小要确保瓶颈资源得到充分利用，并足以维系系统中的稳定流动； 无需浪费时间试图设定一个完美的在制品限额大小，初始化之后，需要在使用过程中不断的试验进行调整； 在制品限制形成的拉动机制：在制品数目小于在制品限额时，才可以从前一阶段拉入新的工作。上图中，开发阶段的在制品限制数目是14，而实际在制品数目是6，可以拉入新的工作；需求验证阶段的在制品数是3，达到了上限，就不允许拉入新工作 创建物理看板 使用看板使用看板进行协调可视化控制和拉动 首先，在制品限额。即我们看到的每一个栏目上标示的限制数字。我们要控制在那个栏目下区域卡片的数量，不能超过在制品限额的数量。例如图四中UE（2）栏目的在制品限额=2，当前没有卡片在那个区域，我们可以从输入列中拉入2张卡片到UE栏目，并开始UE设计工作。 其次，拉动策略。当我们要从输入列中拉入卡片时候，需要根据拉动策略，如工作项类型，到期日，工作项在队列中停留的时间，以及优先级选择合适的卡片到UE栏目。拉动并不是随便拉动，需要根据拉动策略选择工作项。 最后，工作项受阻和延期。根据进入队列的时间和实际日期对比，可以判断出某个工作项是否长期滞留或者受阻。一旦工作项受阻，需要将受阻问题卡片黏贴到这个工作项上以作标示。受阻问题卡片常见表现为，前置工作项卡片，管理问题卡片，或者缺陷卡片。团队需要优先排除受阻问题。让受阻工作项流动起来。 每日站立会 每日站立会是看板管理中的一项活动，聚焦在工作项的流动性问题的协调和解决。会议的组织者一般是项目经理或产品经理，参与人员为一为包括，业务，需求，设计，测试和看板上参与价值流产生和传递的干系人。 站立会的步骤一般是组织者先进行看板的走读。所谓看板的走读，即从后往前，从右到左逐一检查栏目下空间的工作项卡片，主要关注在制品限额是否已经到达上限和受阻和延期的工作项。组织者针对看板的受控项提出问题。然后团队成员简短讨论产生问题的原因，解决方案，并承诺何时可以解决该问题。另外，针对影响流动的其他并未在看板上展示出来的问题组织需要相关人员会后讨论，并协助最终把问题解决。 这种关注流动性问题的站立会，可以让更多人参与进来，同时不会导致会议时间持续过长，我们建议站立会大约15分钟左右。 另外，看板每日站立会来源与Scrum敏捷开发过程中的每日站立会，由于看板上关注了价值流转换中每个人的具体的工作项，每个工作项都可以看到当前的负责人，所以不必再让每个人讲述，昨天做什么，今天计划做什么，遇到了什么障碍类似的问题。需要特别注意的是工作项卡片上必须标示了当前工作项的负责人 调整在制品限额 如果一开始将在制品限额设定得过低，这时候团队可能会发现，在看板墙上可以看见大量代表问题的阻碍项，过小的在制品限额意味着几乎每一件事情都会变得举步维艰，许多人会无事可做而处于空闲状态；例如：开发队列的在制品限额我们设定为4，但是我们有5个开发人员，这样的在制品限额就有可能造成开发人员的产能剩余，工作闲置； 相反的，如果在制品限额设定得太高，那就不能起到在制品限额的可视化问题及预警作用，可能直到问题失控才会引起大家的重视； 例如，下图中开发队列的在制品限额我们一开始设定过高（14），开发的队列不断输入，过了一段时间之后，我们会发现过多的开发造成了等待队列的大量堆积，整个看板系统的流通遇到瓶颈，在这种状况出现之前，我们就应该通过合理的在制品限额来暴露问题 对于能力比较强且有较高成熟度的组织，由于预期之外的问题很少，所以可以考虑采用约束较为严格的在制品限制规则，对于成熟度较低的组织，把在制品的限制规则设得比较宽松为好，开始时，设得大一些，通过创建持续改进的驱动力，将其逐步调低，所有的在制品限额都需要通过看板系统不断的试验进行调整； 在有了相对合适的在制品限额后，可能会有一些意想不到的变异性因素会导致上游步骤变成一个临时瓶颈，看板系统在该处的在制品限额会让整个工作流停下来解决该处的瓶颈，避免系统产生赌塞和过载，当障碍被排除时，系统便可重新恢复流动； 建立交付节奏交付节奏是指以固定频率交付可用软件的模式。稳定交付节奏十分重要，定期交付有利于建立信任，缺乏可预测性会破坏信任。同时能够引导团队能够围绕交付目标开展工作，并降低了每次交付的协调成本，提高工作效率。 Scrum使用固定时间盒sprint来获得稳定的节奏，一般1-4周。迭代开始时候，确定代办项，然后开始一系列的分析，设计，开发，测试，重构等活动，这些活动都要基于假设代办项粒度足够小，并假设上述一系列活动都可以在时间盒内完成。 看板方法抛弃了固定时间和概念，把优先级排序，开发，交付等活动分离开来，分别对待这些活动，允许每种活动根据自身特性来调整节奏。同时看板方法更倾于更频繁的交付节奏，甚至可以支撑随需或者临时交付。 看板对于交付节奏的处理，主要把创建故事或需求条目的时间点与交付频率分离开。当准备交付时，其他工作仍然处于进行中状态。即输入节奏和交付节奏分离。好处显而易见，由于故事优先级排序活动参与人与交付活动参与人可能有不同，协调活动也不一样，按照各自的节奏和方式工作效率更高。 确定交付节奏并非一件容易的事，交付需要付出协调成本和事务成本，同时要考虑带来的市场价值。频发发布可以降低市场风险但会增加发布成本。假设50人团队，一次发布需要抽出10人投入3天来完成一次代码的交付，那么2周一次发布频率可能带来的成本较高。所以选择怎样的发布频率要根据实际情况来定义。 看板使用过程中，会逐渐形成适合团队的发布频率，也要不断提升效率提升交付节奏。 建立输入节奏 输入节奏：与参会干系人达成共识的定期召开会议的时间间隔，会议中按照优先级来选择代办请求项，填充到持续工程的输入队列中以便开发，通常我们也把这种活动叫做优先级排序节奏； 确定优先级排序节奏：节奏固定的优先级排序：通过与参加优先级排序决策的所有干系人达成一致的以合适的频率定期召开会议，建立优先级排序节奏；一般的建议是，这种会议越频繁越好，这样，输入队列就会越小，从而使系统中的浪费越少，在制品越少，前置时间越短，与此相关的成员和组织间就会更频繁的开展协作；要努力寻找开销最小且最为有效的可能的协调方案，合理情况下，越频繁举行的优先级排序会议越好； 随需或临时性的优先级排序：以固定频率定期召开优先级排序会使事物成本及协调成本逐步降低，而对于会议的效率和节奏都很高的高成熟度组织，可以选择随需或者临时进行的优先级排序； 度量看板度量和管理工作流看板系统是可预测的，专注于保持系统的顺畅流动。物理看板可以提供基本的度量数据，包括在制品数量，前置时间等，同时可基于累积流图进行分析和障碍的解决。电子看板为管理提供了更多的度量数据，为团队的管理和报告提供支撑。 度量元 度量方法累积流图 左面的斜线是累积已经开始的价值项（如用户需求）数目； 右面斜线是累积完成价值项的数目； 两条斜线的垂直距离表示某个时刻已经开始但还没有完成的价值项数目，也就是在制品数量； 两条斜线的水平间距表示价值项从开始到完成的平均前置时间，也就是从概念到交付的响应时间，它是价值流动效率的一个重要衡量； 在制品数量与周期时间成线性关系：在制品数量减少，带来平均前置时间缩短，即流量速率的提升； 斜线的斜率反应的是价值流量速率，也就是每周（或固定时间段内）可以交付的价值项数量，这里的价值可以是故事点数、功能点数等等，团队或组织的目标是要持续提升交付速率； 可以识别工作中的瓶颈：在开发的流程中，我们可以将其中每个不同环节（分析、实现、测试、部署、完成）的工作项数量用不同*颜色的带状区域可视化出来，观察一下，是否有一个区域的在变窄，同时在流程中相对于这个环节之前的环节正在变宽（说明队列正在增长，如下两图示例），如果我们看到了这种情况，我们就在吞吐量最低的地方找到了瓶颈，着手去解决它。 准时交付率通过将预估前置时间和实际前置时间进行对比，展示的是团队的可预测水平，度量一个工作项是否能够如期或者提前交付，估算的准确性是表明系统是否高效运行的一个信息指示器；我们也可以通过度量最近月份以及年度的准时交付率，来判断团队交付能力趋势的提升 初始质量缺陷意味着成本，它会影响看板系统的周期时间和流量速率，度量缺陷与在制品总量和流量速率的趋势是有意义的，我们期望看到缺陷率越来越低，同时周期时间和流量速率不断提升","categories":[{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/categories/研发管理/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://youyunyin.com/tags/笔记/"},{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/tags/研发管理/"}]},{"title":"敏捷开发方法(一) Scrum","slug":"敏捷开发方法-1-scrum","date":"2018-10-25T16:00:00.000Z","updated":"2019-01-19T08:20:09.873Z","comments":true,"path":"2018/10/26/敏捷开发方法-1-scrum/","link":"","permalink":"http://youyunyin.com/2018/10/26/敏捷开发方法-1-scrum/","excerpt":"","text":"Scrum团队-三大角色Scrum团队：由产品负责人、开发团队和Scrum Master组成。 是跨职能的自组织团队 自组织团队自己选择如何最好地完成工作，而不是由团队外的人指导 跨职能团队拥有完成工作所需要的全部技能，不需要依赖团队以外的人 这种团队模式的目的是最大限度地优化灵活度、创造力和生产效率 三大角色： Scrum管理-五事件Scrum 管理: 所有事件是有时间盒限定的 每个事件都有时间限制的 一旦Sprint开始，它的周期也就固定下来了，不能缩短或者延长 Scrum 管理五事件包括： Sprint 计划会议 站立会议 回顾会议 演示会议 Scrum管理实施步骤指南（1） Sprint 回顾会议会议准备 会议物品：白板、便签纸、笔等； 会议资料：通常有《Sprint任务清单》《站立会议问题跟踪表》、《Sprint验证问题一览表》、《燃尽图》 参会人员：PO、SM、Team、敏捷教练； 会议组织：可由SM，或敏捷教练，或任一团队成员组织。 会议氛围：愉悦的环境，如：可采用简易茶话会的形式，促进团队成员轻松打开话题，畅所欲言，也可促进团队成员放下手中的其他工作，把思路带到会议中 会议过程 会议组织者介绍会议目标及会议进程。明确会议规则：回顾会要求每个人都参与，做完一个迭代肯定有感受的，调动大家进行坦诚交流。 上一迭代回顾：将站会问题一览表、燃尽图、验证问题一览表等的问题进行整理回顾，哪些做了，哪些没有完成，遇到了哪些问题。 团队总结：团队成员根据上述展现的情况及自身感受，在便签纸上分别写出认为上一迭代团队或个人做的“好的”及“可改进的”两类意见，两方面各写一条。注意‘可改进’的问题最好写能够改进的。之后由大家逐一讲解便签条内容，并贴到白板相应的一列上。这里要求每个人都要写下来，避免说过就忘了。 确定改进项：团队成员针对每一位提出的问题逐一投票，每人投三票,票数最多的三个问题将在下一跌代解决。之所以定义为三个问题，因为根据业内经验超过三个问题在一个迭代里很难有效解决。 改进措施：强调共同分析，这一过程会将问题提到客观全面的高度，让团队能够更清晰的认识到问题的实质，进行问题分析。问题分析可用到的方法及工具应有很多种，比如头脑风暴、鱼骨图等。对于新的敏捷团队，敏捷教练也要发挥价值，引入一些好的建议及方法。最后挑选出在下轮迭代中切实可行的改进建议并指定责任人。 问题跟进：下一迭代回顾会议总结开始前，大家一起根据《回顾会议问题一览表》回顾上一迭代问题的解决情况直至问题关闭。具体了解：待改进的问题是否落实并得到了 解决?解决办法是否可行？解决办法是否延用？如果没有得到解决就需要 在本次会议上重新进行讨论分析。也可能在解决别的问题同时已解决掉这个问题。 常见问题Q：是否需要邀请领导参加？A：因为回顾会议需要团队成员打开话题，畅所欲言。有些团队领导参加可能会影响到团队成员说真话。所以需根据团队自身情况决定，如1,2两个迭代过后，团队协作较为顺畅，可邀请领导支持者等参加。 Q：是否可以以远程的形式开展会议？A：远程会议形式不仅耗费沟通成本，效果也会较差，SCRUM的一大特点就是Face To face，所以除特殊情况，还是要找个会议室开。 Q：是否强制要求每个人都要发言？A：要求每个人都发言，做完一个迭代肯定会有感受的，参与才能融入其中。 Q：回顾会议的结果是否需要正式记录？A：需要。回顾会议上最终确定要改进的问题及责任人要整理到书面文档里，发送团队全员。并且在下一迭代回顾会议上进行问题跟进，记录改进措施是否可行，问题是否解决。切实改进问题才能达到回顾会议的效果。 Scrum管理实施步骤指南（2） Sprint 计划会议会议准备 邀请与会者：产品负责人、Scrum Master、团队所有成员 在sprint计划会议之前，要确保产品backlog的井然有序（已按优先级排列的产品 Backlog ） 把产品 Backlog 公开给会议中的每个人，保证其可被获取 保证房间环境适合小组讨论，一个比较安静的会议室，有投影仪 每个人都可以获取上次 Sprint 评审会议和 Sprint 回顾会议的结果 用作计划纸牌的卡片 一个任务看板 会议进程第一部分：产品负责人和团队一起，在先前评估的成果基础上，定出 Sprint 目标和Sprint Backlog，决定在Sprint中需要完成哪些工作。 SM把 Sprint 完成周期公开给所有人 SM把 上一次Sprint 评审会议的结果公开给所有人 SM把 上一次Sprint 回顾会议的结果公开给所有人 PO向团队产品阐述产品远景，以及达成该远景所需要完成的产品Backlog，让团队成员了解客户的需求。 整个Scrum团队为了更好地了解Sprint的工作进行讨论。 PO和团队一起确认sprint目标。 团队初步确认要放入sprint中的Backlog。(sprint backlog) 第二部分：决定这些工作如何完成，并评估相应的完成时间。 团队从最重要的故事开始逐一讨论每个故事，估算时间。在必要的情况下拆分backlog条目，建议每个条目最好不要超过一天。拆分工作任务，SM带团队拆分 (task) 产品负责人在必要时修改重要性评分，理清每个条目的含义。(拆分sprint backlog 时做的) 产品负责人和团队需要对“完成”有一致的定义。 确定评审会日期 确定回顾会日期 确定每日站会时间和地点 制作任务看板和燃尽图 Sprint计划会议结束时，开发团队最好能够解释他们将如何以自组织团队的形式完成Sprint目标并开发期望的产品 会议输出 Sprint 目标和 Sprint Backlog 任务看板（含燃尽图） 确定好sprint演示日期 确定好sprint回顾日期 确定好时间地点，供举行每日站会 常见问题参会人员哪些是必须的？PO是必须的，产品需求，客户价值就靠他了；SM必须的，他要保证流程，整个环节里面，他是最了解流程的，会议需要他把握节奏，风险等；团队成员更是必须的。三种角色缺一不可。 sprint应该多长才好？经验证明一般2-4周比较合适，可以拥有足够的敏捷性，又让团队进入“流”的状态，团队刚开始要确定sprint的长度，不要浪费太多时间做分析，选一个可以接受的长度先开始再说，等做完一两个sprint再进行调整。 不过，团队确定了最合适长度之后，就要在长时间内坚持住。因为接下来的迭代过程有的时候会稍稍感觉有点长，有的时候感觉有点短。但保持住这个长度以后，它似乎变成了大家共同的心跳节奏，每个人都感觉很舒服。接下来无须讨论发布日期之类的事情，因为大家都知道：每过三周都会有一个发布。 挑选任务的量是多少合适？建议是（Sprint周期）0.8~（Sprint周期） 1.2，防止乐观估计和悲观估计，保证悲观的时候可以完成，乐观的时候有的做。把0.8~1.2之间的内容放到缓冲区中，以备挑选。 Sprint过程中，Sprint backlog是否可以随意添加？由SM进行风险把控，确保整个Sprint不被影响。需要判断添加的backlog优先级，是否紧急，sprint剩余工作量等进行综合考虑。 在sprint计划会议之前，要确保产品backlog的井然有序，是什么意思？井然有序表示的意思是： 所有重要的backlog条目都已经根据重要性被评过分，不同的重要程度对应不同的分数。 无论任何故事，如果产品负责人认为它会在下一个sprint实现，那它就应该被划分到一个特有的重要性层次。 分数只是用来根据重要性对backlog条目排序。假如A的分数是20，而B的分数是100，那仅仅是说明B比A重要而已，绝不意味着B比A重要五倍。如果B的分数是21而不是100，含义也是一样的。 最好在分数之间留出适当间隔，以防后面出现一个C，比A重要而不如B重要。当然我们也可以给C打一个20.5分，但这样看上去就很难看了，所以我们还是留出间隔来。 是否可以把一个产品backlog当做一个Sprint backlog？看情况而定，如果产品backlog就是一个比较小的特性来说，是可以的，如果产品backlog确实很大，那么作为Sprint backlog来说，就不太合适了。建议每个Sprint backlog最好不要超过一天。 Scrum管理实施步骤指南（1） Sprint日站立会议会议准备 确定会议主持人：SM或团队成员轮流。 确定参会人员：团队所有成员、Scrum Master、产品负责人（可选）、相关人员（可选）。 选择一个合适的固定地点，便于团队成员站立围成一圈进行交流，建议选择靠近团队办公的地点。 确定一个合适的固定时间，便于团队成员养成一个习惯，这样就不要每次开会都要下通知了，建议每日早上9:00。 每日站会时要有任务看板，在看板上粘贴本项目组的任务状态和任务工作量：未开始的任务，进行中的任务，完成的任务。也可以借助一些敏捷的工具，例如JIRA系统，可以电子化sprint backlog。物理看板更有视觉的冲击力，电子看板更便于查询、统计、度量和优化。团队成立初期可以采用物理看板，后续团队在持续迭代的过程中需要进行过程数据分析，以便不断改进优化，电子看板将必不可少 会议进程（15 分钟内） 主持人召集并控制会议时间，会议中注意引导话题，如果相关人员想发表些言论，礼貌地提醒他，该会议只允许让小组成员讨论。 会中团队成员每个人就3个问题回答，并且更新每个任务的进展状态，直接在白板上移动任务贴纸： 昨天我为开发团队达成Sprint目标做了什么？（要关注细节，又不能过分详细） 如果任务状态为已完成，把任务从“待处理”或“处理中”转为“已完成”状态； 如果任务状态为进行中，把任务从“待处理”转为“处理中”状态； 如果任务状态已经是“处理中”，需标明剩余工作量，并说明是否存在阻碍任务完成得问题； 如果任务不在 Sprint Backlog 上，添加这个任务，并标明工作量。 今天我准备如何帮助团队达成Sprint目标？ （当成员间的工作有依赖关系时，会给其他成员一个很好的提醒） 如果任务状态为“待处理”转为“处理中”状态 如果任务状态已经是“处理中”，，需标明剩余工作量，说明是否存在阻碍任务完成得问题 如果任务不在 Sprint Backlog 上，添加这个任务，并标明工作量 遇到有什么事情阻碍了我帮助团队达成Sprint目标？（让团队成员认识到在任何任务中他们都不是孤立的） 如果有阻碍团队开发进度的问题，把该障碍加入到障碍 Backlog 中。 如果有问题需要讨论，但只需要几句话的讨论，那么在会上解决；否则需要详细讨论的，记下来，单独安排一个会议专门讨论。 在会议结束时，主持人计算剩余的工作量，更新燃尽图，预测达成Sprint目标的可能性，可以做个简短的总结，我们在何处？我们离目标有多远？ 会后SM要及时解决会议上提出的问题，否则会影响大家，反映问题的积极性。 会议输出 得到最新的障碍 Backlog 得到最新的 Sprint Backlog 最新的燃尽图 常见问题每日站会有必要每天召开吗？项目的延期源自每天的延期，所以要每天实时跟踪进展，站立会议必须每天都要开。 每日站会可以用邮件代替吗？站立会议重在面对面的沟通，不能用邮件替代，E-mail只会增加沟通成本，而且不能提供细节信息或者给他人问问题的机会。 每日站会仅仅是状态汇报吗？每日站会不是状态汇报，避免团队成员陷入提供状态相关信息的这样一种模式。 真正价值在于优化开发团队达成Sprint目标的可能性，激励团队成员不断地为达成“承诺”而努力。 每日站会项目组外部的管理人员能够参加吗，可以发言吗？站立会议只允许团队成员讲话，项目组外部的管理人员可以列席，尤其是主管领导，但不能发言，不能下指令，只能旁听。在SCRUM中提倡的是团队自我管理。 每日站会可以坐着开吗？不能围在桌子周围坐着开，所有人站立围成一圈，站立暗示这个会会很短，强迫大家更专注和投入，还可以避免有人坐着收发邮件和其他分心的事情。 站立会是向SM汇报吗？不是，成员在回答三个问题时目光要注视着大家，而不是 Scrum Master，否则就变成了向领导汇报工作。对每个人回答的问题有疑问，其他成员都可以提出，而不是只有Scrum Master 一个人在问。大家是平等的，这也是一种文化的培养。 每日会议时间一般多长？应该控制在15分钟之内，如果要讨论技术问题，会后单独开会，少数人参与讨论。 如果有人开会总是迟到怎么办？建议制定惩罚措施，例如每次罚款10元，定期用罚款买一些小零食给团队成员分享，培养团队守时的文化。 Scrum管理实施步骤指南（1） Sprint 评审会议会议准备 评审会议之前，由测试人员准备本迭代成果的演示环境，PO/需求人员协作测试团队准备演示数据，脚本等。 演示环境建议使用独立的环境，非开发环境。 评审会议之前，PO/需求/测试保证所有迭代已验证条目部署到演示环境。 基于用户业务场景设计演示的操作线路，并保证覆盖到该场景下所有的待演示条目。 PO确定并邀请参会人员，通常有：Scrum团队（PO、SM、开发测试、UE/UI、敏捷教练）、用户/用户代表、其他相关干系人（如：产品线相关人员、管理人员等）。 会议资料通常有：Sprint目标、Sprint backlog等 完成情况说明及产品演示 首先由SM描述本迭代目标,确保参会人员都了解目标。 SM说明本迭代开发任务完成情况，及未完成的原因说明，需求/UE协助补充验证情况，测试依据测试报告补充测试情况。 通常由测试人员依据《Sprint backlog》进行产品演示； 参会人员根据上述演示及说明提出疑问，Scrum团队进行回答，并记 录发现的问题及期望的改进，改进可能是新的功能需求或一个功能的调整完善。 用户/PO最后依据产品演示、需求/UI/测试的验证情况，接受或拒绝 Sprint开发成果。 根据1）中的记录及2）的结果调整PBI。会后根据评审通过情况进行基线标识。 会议输出 《Product Backlog清单及验证》/《Sprint Backlog清单及验证》 《Sprint验证问题一览表》《标识Sprint基线清单》 评审会规则 迭代评审会在迭代结束前的最后一天进行，不能延期； 评审会议时间，建议根据迭代周期时间，一周对应一小时。 演示过程中，建议不要展开讨论，先记录下来演示结束后讨论。 评审通过标准：用户/PO结合演示情况及测试报告决定是否可交付 Scrum 三大工件Scrum工件 定义： 以不同的方式表现工作任务和价值，可以用来提供透明性以及检查和调整的机会； 特性： 透明度： Scrum依赖于透明性，所作出的优化价值和控制风险的决定都是基于所获知的工件状态。工件的状态必须是完全透明的，才能为产品作出决定提供一个坚实的基础；否则，作出的决定就是有缺陷的。 “完成” 定义：统一完成标准，团队理解一致； 产品待办列表 一个有序的列表，其中包含产品需要的一切可能的东西，也是产品需求变动的唯一来源 产品待办列表项包含描述、次序、估算和价值； “产品待办列表细化”指的是为列表项补充细节、估算和排序 监控实现目标的进度 产品负责人至少要在每个Sprint评审会议的时候追踪剩余工作总量。 产品负责人比较这个数量与之前Sprint评审时的剩余工作量，来评估在希望的时间点达成目标的进度。 监控预测进度工具： 趋势燃尽图（burn-downs） 燃烧图（burn-ups） 累积型的工作流（cumulative flows） Sprint待办列表 一组为当前Sprint选出的产品待办列表项，外加交付产品增量和实现Sprint目标的计划 Sprint待办列表拥有足够的细节，因此能够在每日站会中对进度的变化有清楚的认识 随着任务的进行或者完成，团队需要估算并更新剩余的工作量 监控Sprint进度 在Sprint中的任意时间点都可以计算Sprint待办列表中所有剩余工作的总和。 开发团队在每日站会时跟踪剩余的工作量，预测达成Sprint目标的可能性。 团队通过在Sprint中不断跟踪剩余的工作量来管理自己的进度。 增量 一个Sprint完成的所有产品待办列表项，以及之前所有Sprint所产生的增量价值的总和； 在Sprint的结尾，新的增量必须是“完成”的，必须可用并且达到了Scrum团队“完成”的定义的标准； 无论产品负责人是否决定真正发布它，增量必须可用； Scrum Master的职责之一：和Scrum团队以及企业一起增加工件的透明性Scrum Master的职责之二：和Scrum团队一起明确团队的完成标准 燃尽图定义是在项目完成之前，对需要完成的工作的一种可视化表示。燃尽图有一个Y轴（工作）和X轴（时间）。理想情况下，该图表是一个向下的曲线，随着剩余工作的完成，“烧尽”至零。燃尽图向项目组成员和管理层提供工作进展的一个公共视图。 燃尽图描述的是项目团队随着时间的推移而剩余的工作量，它能形象地展示当前迭代中的剩余工作量和剩余工作时间的变化趋势，是反应项目进展的一个指示器。这种可视化的管理方式，能够帮助团队工作进展更加透明。 您可以使用物理的白板＋手工更新来维护燃尽图，也可以使用EXCEL来生成和更新燃尽图也可以使用一些的敏捷团队协作工具（如：Leangoo等）来自动生成和更新燃尽图。 维护燃尽图是项目团队的日常工作。一般在每日例会后（对于敏捷研发项目，是指每日站立会）后，团队会根据任务的完成情况对其进行更新。这种可视化、简单易操作的管理方式能够帮助团队提升协作效率，并使团队工作进展更加透明，而过重的管理工具会成为团队的负担。 项目团队可以从燃尽图中识别出当前迭代的风险和问题，以便及时采取对策解决问题、规避风险。 另外，可以通过对多个迭代的燃尽图的持续分析，来对项目团团队进行持续地改进 实施方法燃尽图组成：燃尽图通常由4个核心部分组成 燃尽图横坐标：表示工期； 燃尽图纵坐标：表示要完成的工作； 计划曲线：假定项目组成员工作生产率恒定下的进度曲线； 实际曲线：实际进度曲线。 燃尽图绘制 绘制时间点：在项目组进行完项目计划会议后进行燃尽图的绘制。对于敏捷研发项目来说，是在每个sprint计划会议后进行该sprint的燃尽图绘制 绘制方法：绘制人员：燃尽图绘制和后续的更新，由项目经理指定人员进行。可以是项目经理、SM、QA或团队里的其他成员 绘制方法：在业界用的比较多的绘制方法有二种（针对故事点燃尽、针对工作量燃尽），如下: 步骤1：画出横轴和纵轴。横轴为工期，纵轴为故事点数【或工作量（人天）】。 步骤2：先出第一个点。第一个点，横坐标为开发周期的第一天，纵坐标为这个工期内估计能完成的总故事点数【或总工作量】。这个工期内估计能完成的总故事点数【总工作量】为计划会上估算的最终结果。 步骤3：找出项目计划结束点。计划结束点，横坐标为开发周期的最后一天，纵坐标为0。也就是计划在项目的最后一天“烧尽”至零。 步骤4：连接第一个点和项目计划结束点，产生的这个线就是“计划曲线” 燃尽图“实际曲线”的更新在每日例会后（对应敏捷研发项目，是指每日站立会），项目负责人安排人员计算出剩余工作的估算之和（剩余的故事点数，或剩余的总工作量），然后在燃尽图上画出一个新的点。直至项目结束，停止更新。 读懂燃尽图对于项目团队来讲，燃尽图可以说的上是最有用的一种信息发射源（Information Radiator）。对燃尽图的分析，有助于把握团队的进展情况，另外可以还揭示很多问题，比如团队的表现如何、如何进一步改进等等。 燃尽图有助于回答的问题，例如： 团队的计划制订情况如何？ 在一个Sprint中，团队对计划的故事的执行情况如何？ 团队是自我管理的么？作为“团队”来说，大家的工作步调一致么？ 团队能进行哪些改进？ 可以借鉴和学习一些敏捷大师对燃尽图的分析和总结，来解读各项目自己的燃尽图，Hiren向我们展示了如右图这张图表： 图表中的蓝线 Hiren给出了自己的看法：该团队的计划并不好，因为线根本就没有触到零点，这其中的原因可能有很多。团队的一致性上也出现了问题，他们需要教练。因此，对于该团队来说，计划与自我管理方面亟需改进 图中的紫线表明该团队已经达成了目标，但并没有主动去更新数字，原因可能有二：要么他们太懒了，没有更新剩余的工作量；要么是在该Sprint的最后舍弃了很多用户故事。 图中的绿线表明对于一个计划良好的成熟团队工作量的燃尽情况，该团队是自我管理并且在整个Sprint中拥有足够的故事要去实现。这条线接近于理想情况，表明了软件开发的复杂性。","categories":[{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/categories/研发管理/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://youyunyin.com/tags/笔记/"},{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/tags/研发管理/"}]},{"title":"QCon2018全球软件开发大会PPT合集","slug":"QCon2018全球软件开发大会PPT合集","date":"2018-10-23T16:00:00.000Z","updated":"2019-01-19T08:20:09.869Z","comments":true,"path":"2018/10/24/QCon2018全球软件开发大会PPT合集/","link":"","permalink":"http://youyunyin.com/2018/10/24/QCon2018全球软件开发大会PPT合集/","excerpt":"","text":"QCon2018全球软件开发大会PPT合集链接: https://pan.baidu.com/s/1CSD8SJg5eMqpoC3TEH3XmQ 密码:lthe QCon大会是由InfoQ中文站主办的全球顶级技术盛会，每年在伦敦，北京，东京，纽约，圣保罗，上海，旧金山召开。自2007年3月份首次举办以来，已经有超万名高级技术人员参加过的QCon大会。 QCon内容源于实践并面向社区，演讲嘉宾依据热点话题，面向5年以上工作经验的技术团队负责人，架构师，工程总监，高级开发人员分享技术创新和最佳实践。 2018 QCon全球软件开发大会演讲专题产品经理必修之用户细分与产品定位产品经理遇到的最大的问题是自认为炫酷的产品没有用户去使用，因此产品经理的第一节必修课就是在确定产品的价值主张之后，对产品的最终用户进行详细的细分与定义，确定产品的定位。 工程师个人成长与技术领导力工程师成长就是从关心自己的事到关心别人的事，再到关心公司的事的历程。本专题将为大家分享个人成长和技术管理的技巧，帮助大家实现从“做人做事”到“带人带事”的职场跃迁。 国际化互联网业务架构随着全球互联网的蓬勃发展，越来越多的公司把业务拓展到国外，这一变化给技术带来很多新的挑战。本专题旨在发掘在国际化架构先行者的经验，碰撞并探索一套可供参考的国际化架构模式。 互联网高可用架构本专题将为您解答大规模互联网系统的架构设计和实现案例，如何做到高可用和可扩展？大规模互联网系统的设计，开发和运维，有哪些值得借鉴的经验和理念？业界有哪些最新的探索实践和踩坑经历？ 后移动互联网时代的技术思考与实践移动互联网进入下半场，相关基础设施建设趋于成熟，跨平台技术仍在不断发展和创新，音视频，移动端AI落地实践，智能硬件，移动端安全等都是不容忽视的话题。希望本专题能给大家带来新的启迪。 大规模基础设施的DevOps探索业务的爆发式增长，让运维大规模基础设施成为了新的痛点。本专题中，来自一线的运维研发同学，为大家分享针对多数据中心，海量服务器和网络配置，跨应用场景，如何搭建高效准确的运维管理监控平台 硅谷人工智能以谷歌，Facebook等公司为代表，硅谷在人工智能等领域一直走在世界前列。本专题将邀请硅谷有代表性互联网公司的技术专家，分享人工智能领域的前沿研发经验。 硅谷运维技术硅谷的互联网公司在运维方面有很多独到之处。像Chaos Engineering和Resilience Engineering在国内外都有很高的关注度。本专题将邀请来自硅谷的专家，分享运维方面的最新工具与实践。 人工智能与业务实践人工智能无疑是近年关注度最高的技术领域之一，很多公司在AI上投入大量资源，推动新技术在不同场景的落地，比如智能助手，自动驾驶等。本主题将从人工智能和业务结合的角度，分享人工智能领域的最新进展。 Java的生态与创新Java的具有生机勃勃的生态圈，一直得到开发人员的青睐，占据开发语言排行首位的.java有坚实的平台，完整的应用开发栈，繁如群星的开源项目，强大软件和互联网公司后盾，同时也在不断创新和进化。 大数据系统架构业务的增长会带来大量数据，很多公司都搭建了自己的大数据处理平台，或者向新的数据平台/框架迁移。本专题将关注大数据平台技术选型，搭建，系统迁移和优化方面的经验。 区块链技术与应用随着各种数字货币的火爆，区块链技术也成为大家关注的焦点。本专题将邀请相关专家，分享区块链在典型业务场景下的落地思考，阐述背后的设计思想和技术架构。 前端新趋势前端技术日新月异，在技术的演进过程中，也有很多设计思想和架构经验值得前端工程师学习本专题将关注3个方面：实践中积累的前端架构经验，典型的前端框架应用经验，新型框架与设计思路。 深度学习技术与应用本专题将关注深度学习技术在具体业务领域的应用与发展。 微服务架构＆无服务器微服务架构近年来受到持续关注，很多公司也在对原有系统做微服务架构改造。本专题将涉及微服务架构模式，改造经验及相关配套技术。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://youyunyin.com/categories/笔记/"}],"tags":[{"name":"开发者大会","slug":"开发者大会","permalink":"http://youyunyin.com/tags/开发者大会/"},{"name":"qcon","slug":"qcon","permalink":"http://youyunyin.com/tags/qcon/"}]},{"title":"hexo结合gitpage搭建无限空间静态博客","slug":"hexo结合gitpage搭建无限空间静态博客","date":"2018-10-18T16:00:00.000Z","updated":"2019-01-19T08:20:09.870Z","comments":true,"path":"2018/10/19/hexo结合gitpage搭建无限空间静态博客/","link":"","permalink":"http://youyunyin.com/2018/10/19/hexo结合gitpage搭建无限空间静态博客/","excerpt":"","text":"什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。生成静态网页即可托管到任何支持静态网页的服务器上。 什么是GitPageGitHub Pages 与GitHub同属一个研发组织，免费为你的GitHub项目提供项目部署和托管服务，一个GitHub账号可以创建一个GitPage空间。GitPage支持静态和markdown语法的项目，并与GitHub上的项目实时同步自动渲染。所以你可以很容易使用GitPage搭建自己的博客。 特别注意：一个GitHub账号只能创建一个GitPage空间，并且名称有特殊要求下文详细说明。 可选框架：jekyll 环境准备12nodejsGit 创建github账号和同名项目 申请账号如:wangzhikui 创建同名项目:wangzhikui.github.io 如图: 进入项目的【setting &gt; GitHub Pages】 如图： 按照描述设置开启即可。 到此为止GitPages已经可以使用，提交到wangzhikui.github.io的静态或markdown形式的文件会自动同步到GitPages空间。可通过http://wangzhikui.github.io访问。 配置域名(无此需要可跳过)一、上一步GitPages设置中设置域名如：wushuning.com二、配置域名的A地址和CNAME别名本域名在阿里云申请，所以登录aliyun.com进入域名配置，域名解析做如下配置 三、项目根目录中添加名为CNAME的文件，内容为 wushuning.com hexo使用安装hexo并使用hexo创建项目安装hexo脚手架工具并使用脚手架创建项目12345npm install hexo-cli -ghexo init wangzhikuiblogcd wangzhikuiblognpm installhexo server 全局安装脚手架hexo-cli 创建一个名为wangzhikuiblog的项目 进入项目目录 安装依赖包 启动服务 服务启动成功出现如下图： 通过http://localhost:4000访问示例程序到此使用hexo创建项目已经完成 手动部署进入项目目录运行命令1hexo g 则会在项目路径中生成一个public文件夹，里边的内容即为hexo为我们生成的所有静态文件。手动将public里边的所有文件git传到wangzhikui.github.io即可。 到此可通过http://wangzhikui.bighub.io或域名（如果配置了）http://wushuning.com访问你的网站。 自动部署打开项目根目录下的_config.yml 找到如下配置:1234deploy: type: git repo: github: git@github.com:wangzhikui/wangzhikui.github.io.git 运行命令1hexo d 则将public下的文件部署到wangzhikui.github.io.git上，我这里只有一个分支master，所以默认，如果要填写分支可以配置repo。建议保持一个分支就可以了。 hexo d 命令push代码使用的是ssh，所以需要配置github的ssh key 关于key生成配置这里不赘述。 注：如果本地要维护两个github账号，这种情况有可能遇到ssh key冲突，该情况在下一篇博文描述 hexo生成的项目目录结构简介使用hexo创建的项目路径如下图： 项目源码 hexo常用命令 命令 简写 描述 hexo server hexo s 启动服务 hexo generate hexo g 生成静态文件 hexo deploy hexo d 将静态文件部署到github上 hexo clean 无 清除缓存文件 (db.json) 和已生成的静态文件 (public) 查看更多命令: hexo 命令大全 本人在部署的时候喜欢使用三个命令组合123hexo cleanhexo ghexo d 使用主题主题文件存放在 /themes下。本博客基于主题hexo-theme-pure 修改而来。大家也可前往hexo 主题库 下载自己需要的主题。 下载主题后放入/thems下 打开项目根目录的配置文件._config.yml.修改配置theme为你主题的文件夹名称即可1theme: hexo-theme-yyy 创建博文通过命令进入项目目录1hexo new test 常见一篇名为test.md的博文，路径在/source/_posts/test.md打开test.md使用markdown编辑即可。 手动创建直接在_posts文件夹下创建一个test.md的文件即可 未完待续 hexo的_config.yml和themes_config.yml分别有哪些重要配置 hexo中博文md文件都有哪些配置 hexo\b中使用gitalk添加评论功能 一个hexo主题\b都包含什么，如何入手修改主题满足自己个性化设置 本地同时维护两个github账号如何设置ssh key","categories":[{"name":"笔记","slug":"笔记","permalink":"http://youyunyin.com/categories/笔记/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://youyunyin.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://youyunyin.com/tags/github/"},{"name":"gitpage","slug":"gitpage","permalink":"http://youyunyin.com/tags/gitpage/"}]},{"title":"web全栈技术图谱v1.0","slug":"web全栈技术图谱v1-0","date":"2018-10-17T16:00:00.000Z","updated":"2019-01-19T08:20:09.871Z","comments":true,"path":"2018/10/18/web全栈技术图谱v1-0/","link":"","permalink":"http://youyunyin.com/2018/10/18/web全栈技术图谱v1-0/","excerpt":"","text":"根据自己接触到的技术体系整理了一个web全栈技术图谱v1.0。做个记录","categories":[{"name":"web前端","slug":"web前端","permalink":"http://youyunyin.com/categories/web前端/"}],"tags":[{"name":"技术图谱","slug":"技术图谱","permalink":"http://youyunyin.com/tags/技术图谱/"}]},{"title":"前后端分离(二)淘宝基于NODEJS的前后端分离","slug":"前后端分离二","date":"2018-10-11T16:00:00.000Z","updated":"2019-01-19T08:20:09.872Z","comments":true,"path":"2018/10/12/前后端分离二/","link":"","permalink":"http://youyunyin.com/2018/10/12/前后端分离二/","excerpt":"","text":"淘宝基于NODEJS的前后端分离 FRONT-END SKILLS 中间件定制平台 “中间件定制平台”项目中用到的SKILLS 前端工程1，纯静态的前台工程，不依赖web server，可独立工程、独立开发 2、开发过程使用JSON file/MockJS，通过配置切换Angular Service数据源12345window.__service.factory('templateRES',function($resource) &#123;var url = framework.getFinalURL('api/template/:method/1','../template/api/:method.json');var json = $resource(url,&#123;&#125;);return json;&#125;); 3、使用AngularJS，构建完善的前端MVC，简单高效的实现业务逻辑 4、使用Bootstrap做UI框架，使用Angular封装过的KendoUI/jQWidgets等UI组件，实现复制交互控件 4-2、组件的封装和组织 4-3、组件的HTML化使用 4-4、组件的MVC化控制 后端工程1、Sequelize实现ORM，简化数据库开发工作量12345678910module.exports = function (sequelize, DataTypes) &#123; var WebSite = sequelize.define('Website', &#123; name: DataTypes.STRING, status: DataTypes.INTEGER &#125;, &#123; tableName: 'bf_website', timestamps: false &#125;); return WebSite;&#125; 1-2、Sequelize的Models1234567891011121314151617function Website(_) &#123; _ = _ || &#123;&#125;; this.id = _.id || 0; this.status = _.status || 0; this.name = _.name || '';&#125;Website.findById = function (callback) &#123; Website.find(&#123; where: &#123;'id': this.id &#125; &#125; ).complete(function (err, obj) &#123; callback(err, obj); &#125;);&#125;;Website.prototype.save = function(callback) &#123; Website.create(this).complete(function (err, obj) &#123; callback(err, obj); &#125;);&#125;;module.exports = Website; 2、使用LinqJS，进一步简化ORM对象的操作12345678var Enumerable = require('linq');var xpath = Enumerable.from(xpathArr).select(function(xpath)&#123; if(xpath.name == inputs.xpath.name)&#123; xpath = 'new value'; &#125; return xpath;&#125;).toArray(); 3、使用ThenJS，直观管理数据库的多表操作123456789101112131415161718then(function(defer)&#123; WebsiteDomain.del(inputs.ids , defer);&#125;).then(function(defer, value)&#123; Xpath.delByDomainId(inputs.ids, defer);&#125;).all(function (defer, err) &#123; if(!err)&#123; callback(null, &#123; code: '00',message: 'success.' &#125;); &#125;&#125;).fail(function (defer, err) &#123; callback(null, &#123; code: '01',message: err &#125;);&#125;); 4、自行开发的API系统（Model Proxy?）,使NodeJS后端服务化，直接向前端开放业务接口 4-2、API的调用 实践中的全端开发技术家族","categories":[{"name":"web前端","slug":"web前端","permalink":"http://youyunyin.com/categories/web前端/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://youyunyin.com/tags/web前端/"},{"name":"笔记","slug":"笔记","permalink":"http://youyunyin.com/tags/笔记/"}]},{"title":"前后端分离(一)为什么要做前后端分离","slug":"前后端分离一","date":"2018-10-10T16:00:00.000Z","updated":"2019-01-19T08:20:09.872Z","comments":true,"path":"2018/10/11/前后端分离一/","link":"","permalink":"http://youyunyin.com/2018/10/11/前后端分离一/","excerpt":"","text":"前后端存在的问题前端代码越来越复杂 无法统一协作模式，代码充满了约定 JS跟CSS，依赖于后端产出的HTML 有的数据来自AJAX，有的数据印在DOM上 有的业务逻辑在前端，有的在Model层，更多的是在View层 前后端依旧高度耦合 前端依赖服务端开发环境 在服务端View层高度耦合 沟通成本高 职责不清晰 VIEW层谁来维护？前端写Demo，后端套页面 后端需要写HTML 前端仍然确认后端写的HTML前端写View层，后端只管数据 前端需要熟悉后端语言 前端需要了解后端架构 无法良好的支持跨终端 业务逻辑散落在应用中 渲染逻辑强依赖后端页面 只能用responsive design（响应设计）硬来 高度耦合的前后端分工 沟通成本上升 维护成本上升 无法正确且快速的响应变化 代码的腐烂只是迟早的问题 CLIENT-SIDE MV* 时代 接口分离, 后端提供数据, 前端自己搞 Model层 - JavaScript Object View层 - JavaScript Template 业界的优秀方案 AngularJS Backbone EmberJS KnockoutJS React 前后端职责清晰了后端 提供数据 处理业务逻辑 Server-side MVC架构 代码跑在服务器上前端 接收数据，返回数据 处理渲染逻辑 Client-side MV* 架构 代码跑在浏览器上 新问题各层职责重叠，并且各玩各的 Client-side Model 是 Server-side Model 的加工 Client-side View 跟 Server-side是 不同层次的东西 Client-side的Controller 跟 Sever-side的Controller 各搞各的 Client-side的Route 但是 Server-side 可能没有 重用问题 模版无法重用，造成维护上的麻烦与不一致 逻辑无法重用，前端的校验后端仍须在做一次 路由无法重用，前端的路由在后端未必存在 跨终端问题 业务太靠前，导致不同端重复实现 逻辑太靠前，造成维护上的不易 SEO问题渲染都在客户端，模版无法重用，SEO实现麻烦 新的解决方案NODEJS 我们有机会从工作职责上 重新定义前后端的分层 重新定义的前后端 基于NODEJS全端开发 Design and building a team or a company which builds great products.后记 使用nodejs我们可以 转发数据，串接服务 路由设计，控制逻辑 渲染页面，体验优化 中间层带来的性能问题，在异步ajax转成同步渲染过程中得到平衡 更多的可能","categories":[{"name":"web前端","slug":"web前端","permalink":"http://youyunyin.com/categories/web前端/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://youyunyin.com/tags/web前端/"},{"name":"笔记","slug":"笔记","permalink":"http://youyunyin.com/tags/笔记/"}]},{"title":"vue基础教程(使用vue-cli搭建开发环境)","slug":"vue基础教程-使用vue-cli搭建开发环境","date":"2018-10-09T16:00:00.000Z","updated":"2019-01-19T08:20:09.871Z","comments":true,"path":"2018/10/10/vue基础教程-使用vue-cli搭建开发环境/","link":"","permalink":"http://youyunyin.com/2018/10/10/vue基础教程-使用vue-cli搭建开发环境/","excerpt":"","text":"vue环境搭建https://mp.weixin.qq.com/s/izYPuxjgxLuoay75cYKglw","categories":[{"name":"vue","slug":"vue","permalink":"http://youyunyin.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://youyunyin.com/tags/vue/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://youyunyin.com/tags/vue-cli/"}]},{"title":"markdown常用语法","slug":"markdown","date":"2018-09-30T16:00:00.000Z","updated":"2019-01-19T08:20:09.871Z","comments":true,"path":"2018/10/01/markdown/","link":"","permalink":"http://youyunyin.com/2018/10/01/markdown/","excerpt":"","text":"本文参考 Github markdown 基本写法，更多详细描述可直接前往Github查看 目录 标题 文本样式 引用文本 引用代码 链接 部分链接 123456- [标题](#标题)- [文本样式](#文本样式)- [引用文本](#引用文本)- [引用代码](#引用代码)- [链接](#链接)- [部分链接](#部分链接) 标题文字前使用(1-6个)#，不同数量代表文字不一样大小 标题1标题2标题3标题4标题5标题6123456# 标题1## 标题2### 标题3#### 标题4##### 标题5###### 标题6 文本样式 样式 语法 快捷键 示例 效果 粗体 ** **或__ __ command/control + b **Hello World** Hello World 斜体 * *或_ _ command/control + i *Hello World* Hello World 删除 ~~ ~~ 无 ~~Hello World~~ Hello World 粗体&amp;斜体 ~~ ~~和_ _ 无 **Hello _World_** Hello World 表格源码123456| 样式 | 语法 | 快捷键 | 示例 | 效果 ||:----|:----:|-----:|-----:|----:|| 粗体 | `** **`或`__ __` | command/control + b | `**Hello World**` | **Hello World**|| 斜体 | `* *`或`_ _` | command/control + i | `*Hello World*` | *Hello World* || 删除 | `~~ ~~` | 无 | `~~Hello World~~` | ~~Hello World~~ || 粗体&amp;斜体 | `~~ ~~`和`_ _` | 无 | `**Hello _World_**` | **Hello _World_** | 引用文本使用 &gt;，可以使用多个&gt;来嵌套 被引用的文字 被引用的文字2 被引用的文字3 123&gt; 被引用的文字&gt;&gt; 被引用的文字2&gt;&gt;&gt; 被引用的文字3 引用代码使用如下标志将文字包含即可 12345使用``` ``` 将代码包含即可也可以加上语言来使得块中语法高亮 ``` java ``` javascript ``` html 基础\b格式123git statusgit addgit commit java123public static void main(String[] args)&#123; System.out.print(\"Hello World\")&#125; javascript123function sayHello()&#123; console.log('Hello World')&#125; html123&lt;div&gt; &lt;h1&gt; Hello World &lt;/h1&gt;&lt;/div&gt; Github使用Linguist进行语言检测，并选择第三方语法进行语法突出显示。您可以在YAML文件中找到哪些关键字是有效的。 链接1[友云音](http://yyy.yonyoucloud.com) 友云音 链接可以使用相对地址 语法 目录 / 根目录 ./ 当前目录 ../ 上级目录 1[友云音logo](/images/logo/youyunyin-logo.png) 友云音logo 部分链接当我们写好md发布渲染生成html之后，当鼠标移动到某一块的头部的时候会显示#（也有可能是其他图表），点击之后地址栏会生成一个部分连接。使用该地址栏的地址访问该文章会自动定位到点击的这个块。比如本文的地址是:http://youyunyin.com/2018/10/01/markdown/点击[文本样式]这个标题，地址\b栏url变为http://youyunyin.com/2018/10/01/markdown/#文本样式点击改链接就会直接进入该页面并跳转到[文本样式]块中 列表使用 - 或者 * 第1行 第2行 第2-1行 第2-1-1行 第2-1-2行 第2-2行 第3行 1234567- 第1行- 第2行 - 第2-1行 - 第2-1-1行 - 第2-1-2行 - 第2-2行- 第3行 使用数字 第1行 第2行 第3行 1231. 第1行2. 第2行3. 第3行 任务列表（gihub扩展，非标准markdown） 任务1 任务2 任务3 123- [x] 任务1- [ ] 任务2- [ ] 任务3 段落文字后面输入两个空格换行 图片1![友云音logo](/images/logo/youyunyin-logo.png &quot;友云音logo&quot;) 分割线使用 三个以上 - 或 *1234-------*******","categories":[{"name":"markdown","slug":"markdown","permalink":"http://youyunyin.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://youyunyin.com/tags/markdown/"}]},{"title":"codereview常见问题","slug":"codereview常见问题","date":"2018-07-20T16:00:00.000Z","updated":"2019-01-19T08:20:09.870Z","comments":true,"path":"2018/07/21/codereview常见问题/","link":"","permalink":"http://youyunyin.com/2018/07/21/codereview常见问题/","excerpt":"","text":"路线图 常见代码问题常见的潜在代码问题是当前直接会导致BUG、故障或者产品功能不能正常工作的类别。 空值空值是最容易的问题 值为NULL导致空指针异常； 参数字符串含有前导或后缀空格没有Trim导致查询为空。 原则上，对于任何异常， 希望能够打印出具体的错误信息，根据错误信息很快明白是什么原因， 而不是一个 null ，还要在代码里去推敲为什么为空。这样我们必须识别出程序中可能的null， 并及时检测、捕获和抛出异常。 对于空值，最好的防护是“防御式编程”。当获取到对象之后， 使用之前总是判断是否为空，并适当抛出异常、打错误日志或做其它处理。 有的人嫌检测为空的 if 语句充斥在代码里会破坏代码的可维护性， 对此我的建议是： 空值检测一定要有， 有胜于无。在空值检测总是存在的前提下， 可以优化空值检测的方法和存在形式。 比如集中于一个类 NullChecker 中管理，并与系统的整体错误处理设计保持一致。集中管理和处理一致性原则可以作为系统设计的一个准则。 这样主流程中只要增加一行调用即可， 既可以天网恢恢疏而不漏地检测对象为空， 也不会让代码显得难看。12345class NullChecker &#123; public static void checkNull(Object obj, Error error) &#123; if (obj == null) &#123; throw new BizException(error); &#125; &#125;&#125; 在参数入口处统一做 trim。 如果在业务逻辑里做 trim ， 就会导致有的业务逻辑做了 trim ， 有的没做， 体现在产品上就会有令用户困惑的事情发生。 比如搜索和导出业务， 搜索能搜索出来， 导出却没有。 未捕获潜在的异常第二个容易出错的地方是未捕获潜在的异常。调用API接口、库函数或系统服务等，只顾着享受便利却不做防护，常导致因为局部失败而影响整体的功能。最好的防护依然是“防御式编程”。 要么在当前方法捕获异常并返回合适的空值或空对象，要么抛给高层处理。 切不可默默”吞掉错误和异常”。 如果这样做了， 出问题了等着加班和耗费大量脑细胞吧！在CodeReview的时候一定要仔细询问：这里是否可能会抛出异常？如果抛异常会怎么处理？是否会影响整体服务和返回结果？ 低性能低性能会导致产品功能不好用、不可用，甚至导致产品失败。 常见情况有： 循环地逐个调用单个接口获取数据或访问数据库; 重复创建几乎完全相同的(开销大的)对象； 数据库访问、网络调用等服务未处理超时的情况； 多重循环对于大数据量处理的算法性能低； 大量字符串拼接时使用了String而非StringBuilder. 处理建议 最好提供批量接口或批量并发获取数据； 将可复用对象抽离出循环，一次创建多次使用； 设置合理的超时时间并捕获超时异常处理； 使用预排序或预处理， 构造合适的数据结构， 使得算法平均性能在 O(n) 或 O(nlogn) ； 少量字符串拼接使用String, 大量字符串拼接使用 StringBuilder， 通常不会使用到 StringBuffer. 影响范围过大对多个模块依赖的公共函数的修改，容易造成影响范围超过当前业务改动，无意识地破坏依赖于该公共函数的其他业务。要特别慎重。可靠的方式是：先查看该公共函数的调用， 如果只有自己的业务用，可适当大胆一些； 如果有多个地方依赖，抽离一个新的函数，抽离原函数里的可复用部分，然后基于可复用部分构建新的函数。修改原则遵循“开闭”原则，才能尽可能使改动影响降低到最小化。 基类及实例字段和方法也属于公共函数的范畴。 尽量不要修改基类的东西。 单测问题单测是保证工程质量的第一道重要防线。单测问题一般包括： 单测未全部通过； 重要业务逻辑缺乏单测； 缺乏异常单测； 代码变更或BUG修复缺乏单测。 单测全部通过应当是提交代码到代码库以及代码Review的前提条件。代码提交者应当保证单测全部通过。没有捷径可走。仅当单测全部通过才提交到代码库， 可以通过工具自动化实现。 对于 maven 管理的工程， 只需一个命令：1mvn test &amp;&amp; git push origin branch_name 。 单测应当更注重质，而非单纯追求覆盖率。 缺乏单测的重要业务逻辑就像裸露在空气中的电线一样，虽然能跑起来，却是很容易“触电”的。 方法： 增加覆盖比较全面的单测。 缺乏异常单测也是代码提交者常忽略的问题。 异常也是一种实际的业务场景，反映系统的健壮性和友好性。异常应该有相应的单元测试覆盖。创建条件使之抛出异常，并判断异常是否是指定异常；若没有抛出异常或者不是指定异常，则应该 AssertFailed 而不是通过。 对于代码变更和BUG修复，如果当时由于时间紧而没有写，后续应当补上。对于每个代码变更和BUG，都可以抽离出相应的代码部分， 并有相应单测覆盖，并注明原因。 与原有业务逻辑不兼容改动针对当前需求是合理的，却与原有业务逻辑不兼容，也是常见的问题。比如增加一个搜索条件， 却不能与原有条件联合查询。 与原有业务不兼容， 一般出现在： 一对一与一对多的变化。 比如原来的关系是一个订单对应一个物流信息， 后来变化为一个订单可能对应多个物流信息； 原来的逻辑是一个订单显示多个物流信息可以更改，后来要求一个订单只展示最近一次的物流信息可以修改。多个业务组合。 业务 A 与业务 B 原来是分开发展的， 后来开展一种活动，将业务A与业务B进行一种组合营销。 此时，多半会出现很多 if-else 语句。 业务逻辑的兼容问题一般体现在系统的复用性和可扩展机制上。良好的系统可复用性和可扩展性可以更容易地做到业务逻辑兼容。 主要有如下几种级别： 自动兼容。 增加一种类型， 只是 biz_type 的值多了一种， 系统自动将已有功能适配给新的 biz_type；一点改动。增加一个分支语句， 对 biz_type 的某个特性进行扩展；一些改动。 需要见缝插针地增加一个单独的分支判断和逻辑处理模块， 对整体可扩展性没有影响， 但会造成局部的复杂化；一部分功能改动。 只需要对其中一个功能模块做个扩展；多处改动。 需要对多个功能模块做相应的改造，不过更多是新增而不是修改；难以改动。 需要深入到功能模块内部做艰难的修改， 并要保证原有功能不受影响。 如何应对呢？ 针对关联关系， 在项目之初， 可以询问清楚： 将来在产品上是否有可扩展的变化？ 及早预留空间， 或者确定产品上的对策； 在代码实现上， 兼顾考虑一对一到一对多，或一对多到一对一的关联变化。比如使用列表来表达单个信息， 使用索引从列表中获取单个信息。针对业务组合， 明确各业务的核心部分， 抽离出业务的可复用的部分，形成 API ； 考虑组合模式和装饰器模式来进行扩展。 核心不变， 外围定制化。 缺乏必要日志对于重要而关键的实例状态、代码路径及API调用，应当添加适当的INFO日志；对于异常，应当捕获并添加Error日志。缺乏日志并不会影响业务功能，但出现问题排查时，就会非常不方便，甚至错失极宝贵的机会(不易重现的情况尤其如此)。此外，缺乏日志也会导致可控性差，难以做数据统计和分析。 错误码不符合规范错误码本身不算是代码问题，不过基于整个组织和工程的可维护性来说，可以将错误码不符合规范作为一种错误加以避免。方法： 对错误码进行可控的管理和遵循规范使用。可以使用公共文档维护， 也可以开发错误码管理系统来避免相同的错误码。 参数检测缺乏或不足参数检测是对业务处理的第一层重要过滤。如果参数检测不足够，就会导致脏数据进入服务处理，轻则导致异常，重则插入脏数据到数据库，对后续维护都会造成很多维护成本。方法： 采用“契约式编程”，规定前置条件，并使用单测进行覆盖。 对于复杂的业务应用， 优雅的参数检测处理尤为重要。 根据 “集中管理和处理一致性原则”， 可以建立一个 paramchecker 包， 设计一个可复用的微框架来对应用中所有的参数进行统一集中化检测。参数检测主要包括： (1) 参数的值类型， 可以根据不同值类型做基础的检测； (2) 参数的业务类型， 有基础非业务参数， 基础业务参数和具体业务参数。 不同的参数业务类型有不同的处理。 将参数值类型与参数业务类型结合起来， 结合一致性的异常捕获处理， 就可以实现一个可复用的参数检测框架。参数检测既可以采用普通的分支语句，也可以采用注解方式。采用注解方式更可读，不过单测编写更具技巧。 引用错误对于动态语言， 由于缺乏强大的静态代码检测，修改了类引用的地方尤其要注意，很可能导致依赖的其他业务出错； 尤其是修改重名引用时。有线上故障教训。PHP工程中含有两个 Format 类， 一个基础的一个业务相关的， 被改动的类文件里开始没有指明引用，默认采用了基础 Format 类的实现， 然后提交者在改动文件头增加了对业务 Format 的引用， 导致依赖于基础Format类的其他业务不能正常工作。避免引用错误的方法： 当要在文件里增加新的类引用时， 先在文件里搜索是否有重名类的引用。如果有， 就要格外小心了。 细节错误比如数组越界、JSON解析出错、函数参数传递出错、API 版本不对、使用网上拷贝的未经测试的代码、不成熟的算法、传值与传引用、相等性比较等。 对于数组越界错误， 通常要对空数组、针对数组大小的边界值+1和-1写单测来避免； 使用网上拷贝的代码，诚然可节省时间，也一定要加工一下并用单测覆盖； 传值和传引用可通过单测来避免错误； 对象的相等性比较切忌使用等号=。 多重条件类似 if ((!A || !B) &amp;&amp; C || (D &amp;&amp; E)) 的多重条件要仔细推敲。方法： 最好拆分成多个有含义变量。 isNotDelay = !A || !B ; isNormal = C ; isAllow = D &amp;&amp; E ; cond = isNotDelay &amp;&amp; isNormal || isAllow 。 文不符实文不符实是一种可能导致线上故障的错误。比如一个 getXXX 的函数，结果里面还做了 add, update 的操作。对问题排查、产品运维等都有非常大的杀伤力。因此命名一定要用实质内容相符，除非是故意搞破坏。 跨语言或跨系统交互稍具规模的互联网创业公司通常会采用多语言开发，比如PHP作为前端，Java作为后台服务。当动态类型语言与静态类型语言交互时，会有一些问题产生。比如PHP的对象通常是一个Map, 如果是空对象就会写成 [], 然而 [] 会被 Java 解析成列表。这样， 如果数据库的值是通过 PHP 写入，那么这个值既有可能是JSON对象字符串，也可能是空数组字符串， Java 来解析就有点尴尬了。 同样，当 Java 调用 PHP 接口时， 不规范的PHP接口既可能返回列表，也可能返回 true or false ， Java 解析返回结果也会比较尴尬。 因此， 在跨语言交互的边界处，要特别注意这些类型转换的差异。 跨系统交互则主要是接口设计与约定的问题。同一个项目里不同业务团队之间的业务接口设计与约定， 不同企业里开放接口的设计与约定， 要在最初深思熟虑，一旦开放，在后期很少有接口设计改动的空间。开放接口设计要符合小而美、正交的特性， 命名要贴切一致， 参数取值要指明约束，枚举参数要给出列表， 结果返回要规范一致，可以采用通用的 {“code”:200, “msg”: “success”, “data”: xxx} 。跨系统交互也要统一对术语和接口的理解的一致。","categories":[{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/categories/研发管理/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://youyunyin.com/tags/笔记/"},{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/tags/研发管理/"}]},{"title":"MAC破解安装IntelliJ IDEA方法","slug":"MAC破解安装IntelliJ-IDEA方法","date":"2018-01-10T16:00:00.000Z","updated":"2019-01-19T08:20:09.868Z","comments":true,"path":"2018/01/11/MAC破解安装IntelliJ-IDEA方法/","link":"","permalink":"http://youyunyin.com/2018/01/11/MAC破解安装IntelliJ-IDEA方法/","excerpt":"","text":"MAC下破解安装Intellij IDEA 2017 方法破解的版本：12345678IntelliJ IDEA 2017.3.2 (Ultimate Edition) Build #IU-173.4127.27, built on December 26, 2017 Licensed to Rover12421 / Rover12421 You have a perpetual fallback license for this version Subscription is active until December 31, 2099 JRE: 1.8.0_152-release-1024-b8 x86_64 JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o Mac OS X 10.13.2 1、下载IntelliJ IDEA 2017IDEA官网下载无限制版 2、下载破解文件JetbrainsCrack-2.6.2.jar进入下载界面 3、安装IntelliJ IDEA 20174、安装后Applications文件夹中找到IDEA,右键show package contents找到bin目录下，将下载的\b破解文件拷贝到该目录下 5、打开上图中的idea.vmoptions追加如下配置1-javaagent:/Applications/IntelliJ IDEA.app/Contents/bin/JetbrainsCrack-2.6.10-release-enc.jar 6、启动IDEA 提示需要注册，将获取的注册码填入Help &gt; Register选中Activation code 将注册码填入下面的输入框中即可","categories":[{"name":"mac","slug":"mac","permalink":"http://youyunyin.com/categories/mac/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://youyunyin.com/tags/idea/"},{"name":"mac","slug":"mac","permalink":"http://youyunyin.com/tags/mac/"},{"name":"研发工具","slug":"研发工具","permalink":"http://youyunyin.com/tags/研发工具/"}]},{"title":"Java性能调优的11个实用技巧","slug":"Java性能调优的11个实用技巧","date":"2017-11-23T16:00:00.000Z","updated":"2019-01-19T08:20:09.868Z","comments":true,"path":"2017/11/24/Java性能调优的11个实用技巧/","link":"","permalink":"http://youyunyin.com/2017/11/24/Java性能调优的11个实用技巧/","excerpt":"","text":"作者：ITeye来源：ITeye[http://www.iteye.com/news/32754] 大多数开发人员认为性能优化是个比较复杂的问题，需要大量的经验和知识。是的，这并不没有错。诚然，优化应用程序以获得最好的性能并不是一件容易的事情，但这并不意味着你在没有获得这些经验和知识之前就不能做任何事。下面有几个很容易遵循的建议和最佳实践能够帮你创建一个性能良好的应用程序。 这些建议中的大多数都是基于Java的，但是也不一定，也有一些是可以应用于所有的应用程序和编程语言的。在我们分享基于Java的性能调优技巧之前，让我们先讨论一下这些通用的性能调优技巧。 1.在必要之前，先不要优化这可能是最最重要的性能调优技巧之一。你应该遵循常见的最佳实践，并尝试有效地实现你的用例。但这并不意味着在证明它是必要之前，替换任何标准库或构建复杂的优化。 在大多数情况下，过早的优化占用了大量的时间，使得代码难以读取和维护。更糟糕的是，这些优化通常不会带来任何好处，因为你花费了大量时间来优化应用程序的非关键部分。 那么，你如何证明你需要优化某些东西呢? 首先，你需要确定应用程序代码的速度，例如，为所有API调用指定一个最大响应时间，或者指定在特定时间范围内导入的记录数量。完成之后，你可以度量应用程序的哪些部分太慢而需要改进。当这样做之后，那么请继续看第二个调优技巧。 2.使用分析器来找到真正的瓶颈在你遵循第一条建议，并确定你的应用程序的某些部分的确需要改进之后，问自己从哪里开始? 你可以用两种方法来解决这个问题: 你可以看一下你的代码，从看起来可疑或者你觉得它可能会产生问题的部分开始。或者使用分析器，获取代码中每个部分的行为和性能的详细信息。至于为什么应该总是遵循第二种方法。 答案应该很明显，基于分析器的方法能让你更好地理解代码的性能含义，并允许你关注最关键的部分。如果你曾经使用过分析器，你将会惊讶于代码的哪些部分造成了性能问题。然而，很多时候，你的第一次猜想会把你引向错误的方向。 3 .为整个应用程序创建性能测试套件这是另一个帮助你避免许多意想不到问题的一般技巧，这些问题通常发生在性能改进部署到生产环境之后。你应该经常定义测试整个应用程序的性能测试套件，并在你完成性能改进之前和之后运行它。 这些额外的测试运行将帮助你识别更改的功能和性能方面的影响，并确保你不会发布一个弊大于利的更新。如果你的任务运行于应用程序的多个不同部分比如数据库或缓存，这一点尤其重要。 4.首先解决最大的瓶颈问题在创建了测试套件并使用分析器对应用程序进行分析之后，你就有了一个需要提高性能的问题列表，这很好，但它仍然不能回答你应该从哪里开始的问题。你可以从那些可以快速搞定的开始，亦或者从最重要的问题开始。 当然前者很诱人，因为这很快就能出结果。有时，可能需要说服其他团队成员或你的管理层，性能分析是值得的。 但总的来说，我建议首先着手处理最重要的性能问题。这将为你提供最大的性能改进，而且你可能只需要修复这些问题中的几个就可以解决你的性能需求。 在了解通用性能调优技巧之后，让我们再来仔细看看一些特定于Java的调优技巧。 5.使用StringBuilder以编程方式连接字符串在Java中有许多不同的连接字符串的选项。例如，可以使用一个简单的+或+ =、老的StringBuffer或StringBuilder。 那么，你应该选择哪种方法呢? 答案取决于连接字符串的代码。如果你以编程方式向字符串中添加新内容，例如，在for循环中，你应该使用StringBuilder。它比StringBuffer更容易使用和提供更好的性能。但是请记住，StringBuilder与StringBuffer不同，它不是线程安全的，而且可能不适合所有用例。 你只需要实例化一个新的StringBuilder，并调用append方法在字符串中添加一个新的部分。当你添加了所有的部分后，可以调用toString()方法来检索连接字符串。 下面的代码片段展示了一个简单的示例。在每次迭代过程中，这个循环将i转换成一个字符串，并将其添加到StringBuilder sb的空间中，因此到最后，这段代码写入“this is test0123456789”到日志文件。 123456StringBuilder sb = new StringBuilder(“This is a test”); for (int i=0; i&lt;10; i++) &#123; sb.append(i); sb.append(” “); &#125; log.info(sb.toString()); 正如在代码片段中看到的，你可以为构造函数方法提供字符串的第一个元素。这将创建一个新的StringBuilder，其中包含提供的字符串和16个额外字符的容量。当你向StringBuilder中添加更多字符时，JVM将动态地改变StringBuilder的大小。 如果你已经知道自己的字符串包含多少字符，那么你可以向不同的构造函数方法提供这个数字，以实例化一个具有被定义容量的StringBuilder。这进一步提高了它的效率，因为它不需要动态扩展它的容量。 6.在声明中使用+连接字符串当你在Java中实现第一个应用程序时，可能有人告诉你不应该用＋来连接字符串。如果在应用程序逻辑中连接字符串这是正确的。字符串是不可变的，每个字符串连接的结果存储在一个新的字符串对象中。这需要额外的内存，并降低应用程序的速度，特别是在循环中连接多个字符串时。 在这些情况下，你应该遵循tip 5并使用StringBuilder。 但如果你只是将一个字符串分解成多行来提高代码的可读性，那就不是这样了。 123Query q = em.createQuery(“SELECT a.id, a.firstName, a.lastName ” + “FROM Author a ” + “WHERE a.id = :id”); 在这些情况下，你应该用一个简单的+来连接你的字符串。Java编译器将优化它并在编译时执行连接。因此，在运行时，代码只使用1个字符，不需要连接。 7.尽可能使用基本数据类型另一种避免开销，提高应用程序性能的快速方法就是使用原始数据类型而不是它们的包装类。因此，最好是使用int而不是Integer，或者是double而不是Double。这将让JVM将值存储在堆栈中，以减少内存消耗，并更有效地处理它。 8.尽量避免BigInteger和BigDecimal由于我们已经讨论了数据类型，我们再来看下BigInteger和BigDecimal。尤其是后者，由于其精度高而受欢迎。但这是有代价的。BigInteger和BigDecimal比简单的long或double需要更多的内存，并且大大降低所有的计算速度。因此，如果你需要额外的精度，或者你的数字超过了一个long范围，最好三思而后行。这可能是你在提升性能问题中唯一需要更改的地方，特别是当你正在实现一个数学算法。 9.首先检查当前日志级别这个建议是显而易见的，但不幸的是，你会发现许多代码忽略它。在创建调试消息之前，应该先检查当前日志级别。 这里有两个例子来说明你不应该这样做。 1234// don’t do this log.debug(“User [” + userName + “] called method X with [” + i + “]”); // or this log.debug(String.format(“User [%s] called method X with [%d]”, userName, i)); 在这两种情况下，你将执行所有需要的步骤来创建日志消息，而不知道日志框架是否使用日志消息。在创建调试消息之前，最好先检查当前日志级别。 1234// do this if (log.isDebugEnabled()) &#123; log.debug(“User [” + userName + “] called method X with [” + i + “]”); &#125; 10.使用Apache Commons StringUtils.Replace 代替String.replace一般来说,String.replace 方法工作得很好，而且非常高效，特别是如果你使用的是Java 9。但是，如果应用程序需要大量的替换操作，并且你还没有更新到最新的Java版本，那么检查更快和更有效的替代方案仍然是有意义的。 一个候选就是 Apache Commons Lang’s StringUtils.replace 方法。正如Lukas Eder在他最近的一篇博客文章中所描述的那样，它大大超过了Java 8的String.replace 方法。 它只需要很小的改变。你只需要为Apache’s Commons Lang 项目增加一个Maven依赖项到你的应用pom.xml，并用StringUtils.replace方法替换所有String.replace方法的调用。 1234// replace this test.replace(“test”, “simple test”); // with this StringUtils.replace(test, “test”, “simple test”); 11.缓存昂贵的资源，比如数据库连接缓存是一种流行的解决方案来避免重复执行昂贵或频繁使用的代码片段。一般的想法很简单:重复使用这些资源比一次又一次地创建一个新的资源要便宜得多。 一个典型的例子就是在池中缓存数据库连接。创建新连接需要时间，如果重用现有连接，则可以避免。 还可以在Java语言本身中找到其他示例。例如，Integer类的valueOf方法缓存了- 128和127之间的值。你可能会说，创建一个新整数并不太贵，但它经常使用，缓存最常用的值提供了性能方面的好处。 但当你考虑缓存时，请记住，缓存实现也会产生开销。你需要花费额外的内存来存储可重用资源，因此可能需要管理你的缓存，以使资源能够访问或删除过时的资源。 因此，在你开始缓存任何资源之前，请确保是经常使用。 总结正如你所看到的，提高应用程序的性能有时不需要做大量的工作。这篇文章中的大多数建议，其实只需要稍微的努力就可以将它们应用到代码中。 但通常最重要的建议是很编程语言无关的: 在你知道有必要之前，不要优化 使用分析器来找到真正的瓶颈 首先解决最大的瓶颈问题","categories":[{"name":"java","slug":"java","permalink":"http://youyunyin.com/categories/java/"}],"tags":[{"name":"java性能","slug":"java性能","permalink":"http://youyunyin.com/tags/java性能/"}]},{"title":"SpringBoot无法启动，启动后报404错误","slug":"SpringBoot无法启动，启动后报404错误","date":"2017-11-23T16:00:00.000Z","updated":"2019-01-19T08:20:09.869Z","comments":true,"path":"2017/11/24/SpringBoot无法启动，启动后报404错误/","link":"","permalink":"http://youyunyin.com/2017/11/24/SpringBoot无法启动，启动后报404错误/","excerpt":"","text":"SpringBoot无法启动可能的原因：直接将启动类放在了src.java.main下解决方案：在main下创建自己的packadge如:src.java.main.com.wzk.starter SpringBoot正常启动，但是访问的时候提示404原因是：controller没有被spring容器扫描到解决方案1：spring boot默认扫描启动类的当前包和下级包比如：启动类在 com.wzk.starter包下，那么spring 会扫描 com.wzk.starter和com.wzk.starter.*如果编写的controller没有放置在这些位置就是报错 解决方案2：配置spring boot的扫描路径在启动类上面添加注解：@ComponentScan(basePackages = {“com.wzk.*”})","categories":[{"name":"springboot","slug":"springboot","permalink":"http://youyunyin.com/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://youyunyin.com/tags/springboot/"}]},{"title":"SpringBoot入门环境搭建，maven构建，Intellij IDEA 2016.2","slug":"SpringBoot入门环境搭建，maven构建，Intellij-IDEA-2016-2","date":"2017-11-23T16:00:00.000Z","updated":"2019-01-19T08:20:09.869Z","comments":true,"path":"2017/11/24/SpringBoot入门环境搭建，maven构建，Intellij-IDEA-2016-2/","link":"","permalink":"http://youyunyin.com/2017/11/24/SpringBoot入门环境搭建，maven构建，Intellij-IDEA-2016-2/","excerpt":"","text":"Intellij IDEA工具下搭建SpringBoot入门程序使用maven环境准备 Intellij IDEA 2016.2 maven 3.0.5 SpringBoot 1.5.8 步骤一、新建项目file-&gt;new-&gt;project创建项目选择maven如下图点击next如图填入自己项目的信息，由于是创建的maven项目，所以此处填写maven需要的字段信息，具体见途中说明点击next这一步填写项目的名称和存储的路径点击finish创建成功到这一步一个简单的maven工程就创建完成了。 二、添加springboot支持pom.xml文件中增加配置123456789101112131415161718192021222324252627282930313233343536373839404142&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 由于最终要打包成jar格式所以pom.xml中还需增加配置1234&lt;groupId&gt;com.wzk&lt;/groupId&gt;&lt;artifactId&gt;spring02&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 注意:jar参数的值为:jar 三、编写测试代码创建类如下，SpringBoot的启动类，如果不做任何配置，默认启动的容器是tomcat12345678910111213package com.wzk.ms;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); &#125;&#125; 再写一个自己的controller类，输入经典的helloworld123456789101112131415package com.wzk.ms;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloWorldController &#123; @RequestMapping(\"/hello\") public String index() &#123; String test = \"Hello\"; String test1 = \" world\"; String returnStr = test + test1; return returnStr; &#125;&#125; 四、启动测试 SpringbootApplication是一个含有main方法的java程序，所以直接运行 浏览器输入http://localhost:8080/hello因为默认是tomcat所以端口默认8080，返回Hello world. 五、配置修改springboot的配置很简单，直接修改resource下的application.properties文件即可。如修改访问端口为8081，添加配置server.port=8081 tomcat的其他配置可以参考server.port=808112345678910111213#server.address= # bind to a specific NIC#server.session-timeout= # session timeout in seconds#the context path, defaults to &apos;/&apos;#server.context-path=/spring-boot#server.servlet-path= # the servlet path, defaults to &apos;/&apos;#server.tomcat.access-log-pattern= # log pattern of the access log#server.tomcat.access-log-enabled=false # is access logging enabled#server.tomcat.protocol-header=x-forwarded-proto # ssl forward headers#server.tomcat.remote-ip-header=x-forwarded-for#server.tomcat.basedir=/tmp # base dir (usually not needed, defaults to tmp)#server.tomcat.background-processor-delay=30; # in seconds#server.tomcat.max-threads = 0 # number of threads in protocol handler#server.tomcat.uri-encoding = UTF-8 # character encoding to use for URL decoding 六、打包成jar打包成可运行的jarintelliJ打开命令行，运行mvn clean package即可默认输出到target目录下，然后输入java -jar xxx.jar即可启动关闭命令行窗口即关闭了容器","categories":[{"name":"springboot","slug":"springboot","permalink":"http://youyunyin.com/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://youyunyin.com/tags/springboot/"}]},{"title":"设计模式-极简笔记-6大设计原则","slug":"设计模式-极简笔记-6大设计原则","date":"2017-10-12T16:00:00.000Z","updated":"2019-01-19T08:20:09.879Z","comments":true,"path":"2017/10/13/设计模式-极简笔记-6大设计原则/","link":"","permalink":"http://youyunyin.com/2017/10/13/设计模式-极简笔记-6大设计原则/","excerpt":"","text":"通过尽量少的语言描述设计模式的相关概念如果想要更详细的描述可参看设计模式其他相关书籍或者资料 6大设计原则单一职责原则英文名称：Single Responsibiity Principle 简称：SRP定义：在定义接口的时候，接口的功能要单一。该原则素来有很多的争议，因为这个原则在实际开发过程中很难界定功能范围，所以需要根据实际情况使用，不要生搬硬套。 里氏替换原则英文名称：Liskov Substitution Principle 简称：LSP通俗定义：只要父类能出现的地方子类就可以出现，而且替换为子类不会产生任何错误或异常该原则主要为继承定义一个规范，子类尽量不要出现父类不存在的方法或属性 依赖倒置原则英文名称：Dependence Inversion Principle 简称：DIP通俗定义：通常依赖都是指的具体实现类的依赖和耦合，这里倒置就是要把依赖放到接口层。具体的实现类之间不存在依赖，实现类只是依赖他们的接口。该原则就是经常谈到的面向接口编程 接口隔离原则英文名称：Interface Segregation Principle 简称：ISP通俗定义：客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。该原则规范了我们对外提供接口时的一个规范，对外提供接口时，只提供需要的接口。比如：提供通过姓名查询用户信息的接口，就提供queryByName(String name),而不是提供一个通用query(String queryParam)，约定参数为{“name”:张三}这样的形式。 迪米特法则英文名称：Law of Demeter 简称：LOD或英文名称：Least Knowledge Principle 简称：LKP本人喜欢第二个描述。通俗定义：一个类再调用其他类或者接口的时候应该对该类有最少的了解，只要知道该接口能实现什么功能即可，至于如何实现，以及过程都不需要关心。 开闭原则英文名称：Open Closed Principle 简称：OCP通俗定义：一个接口，类，模块的定义应该对扩展开放，对修改关闭该原则规范我们在开发过程中尽量通过扩展的方式来实现新的功能或者变化，而不是去修改原有逻辑或者接口","categories":[{"name":"架构设计","slug":"架构设计","permalink":"http://youyunyin.com/categories/架构设计/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://youyunyin.com/tags/设计模式/"}]},{"title":"mac中配置eclipse启动使用的jdk，eclipse.ini文件","slug":"mac中配置eclipse启动使用的jdk，eclipse-ini文件","date":"2017-09-23T16:00:00.000Z","updated":"2019-01-19T08:20:09.870Z","comments":true,"path":"2017/09/24/mac中配置eclipse启动使用的jdk，eclipse-ini文件/","link":"","permalink":"http://youyunyin.com/2017/09/24/mac中配置eclipse启动使用的jdk，eclipse-ini文件/","excerpt":"","text":"设置eclipse使用的jdk application中找到eclipse右键show content找到eclipse的配置文件eclipse.ini 增加配置如下 12-vm/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home 其中jdk的路径可以通过命令1/usr/libexec/java_home -V 最后是大写的V查看","categories":[{"name":"研发工具","slug":"研发工具","permalink":"http://youyunyin.com/categories/研发工具/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://youyunyin.com/tags/mac/"},{"name":"研发工具","slug":"研发工具","permalink":"http://youyunyin.com/tags/研发工具/"},{"name":"eclipse","slug":"eclipse","permalink":"http://youyunyin.com/tags/eclipse/"}]},{"title":"mac中JDK安装配置","slug":"mac中JDK安装配置","date":"2017-09-23T16:00:00.000Z","updated":"2019-01-19T08:20:09.870Z","comments":true,"path":"2017/09/24/mac中JDK安装配置/","link":"","permalink":"http://youyunyin.com/2017/09/24/mac中JDK安装配置/","excerpt":"","text":"系统内置JDKmac默认自带一个jdk6 自定义安装JDK从oracle下载jdk安装后默认安装路径如下1/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home 并且系统内置的jdk会默认为最新安装的 环境变量配置vi .bash_profile输入：1234export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Homeexport CLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH:export PATH 删除已经安装的jdk1sudo rm -rf jdk1.8.0_101.jdk 可以进入12cd /usr/libexecjava_home -V 查看所有jdk的路径1/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home","categories":[{"name":"java","slug":"java","permalink":"http://youyunyin.com/categories/java/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://youyunyin.com/tags/mac/"},{"name":"java","slug":"java","permalink":"http://youyunyin.com/tags/java/"}]},{"title":"mac中配置环境变量","slug":"mac中配置环境变量","date":"2016-12-05T16:00:00.000Z","updated":"2019-01-19T08:20:09.871Z","comments":true,"path":"2016/12/06/mac中配置环境变量/","link":"","permalink":"http://youyunyin.com/2016/12/06/mac中配置环境变量/","excerpt":"","text":"mac修改环境变量修改当前用户环境变量以配置tomcat为例 打开终端：输入如下指令 1wangzhikuiMacBook-Pro:~ wangzhikui$ vi .bash_profile 编辑.bash_prifile文件 在英文输入下按i ，进入编辑状态输入如下 12345678910111213141516export PATH=/Users/wangzhikui/develop/tomcat8.0.39/bin:$PATH:export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_71.jdk/Contents/Homeexport CLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH:export PATH=/usr/local/mysql/bin:$PATH:export M2_HOME=/Users/wangzhikui/develop/apache-maven-3.3.9export PATH=$M2_HOME/bin:$PATH:export PATH=/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin:$PATH:export PATH~ ~ ~ ~ ~ ~ &quot;.bash_profile&quot; 9L, 465C 按esc键后 输入 :wq 保存退出 配置完后退出终端再打开即可在终端中直接输入tomcat的启动，停止命令","categories":[{"name":"mac","slug":"mac","permalink":"http://youyunyin.com/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://youyunyin.com/tags/mac/"},{"name":"环境变量","slug":"环境变量","permalink":"http://youyunyin.com/tags/环境变量/"}]},{"title":"前端技术选型yyy-1.0","slug":"前端技术选型yyy1","date":"2016-05-23T16:00:00.000Z","updated":"2019-01-19T08:20:09.872Z","comments":true,"path":"2016/05/24/前端技术选型yyy1/","link":"","permalink":"http://youyunyin.com/2016/05/24/前端技术选型yyy1/","excerpt":"","text":"前端技术选型一，AngularJS+BootStrap+RequireJSAngularJS 前端js框架，MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入http://www.apjs.net/ http://docs.angularjs.cn/api BootStrap。Css/html框架，前端UI类库http://bootstrap.evget.com/ http://v3.bootcss.com/ RequireJS。Js模块化按需加载工具，遵循AMD提前加载http://www.requirejs.cn/ http://requirejs.org/ 模块化定义规范AMD与CMD http://www.zhihu.com/question/20351507/answer/14859415 特点：angularjs新的前端设计思想，将后端MVC，依赖注入前置，本身就是一套完整的前端mvc架构 前端js单元测试框架QUnit, Mocha 或者 Jasmine 二，Jquery+Bootstrap+RequireJS特点：主流前端开发思想，简单，上手快，对于前端功能不复杂的情况非常实用 三， React + Redux + RequireJS + jQuery(或Zepto) + UIKit(或Bootstrap、SUI)+ReactRouter(单页面路由器框架)React技术背景：Facebook于13年发布的开源框架，技术针对模型层和数据层，地址： http://facebook.github.io/react/ React技术特点： 采用虚拟DOM技术，可以高效率进行DOM渲染； 组件化组装式开发模式，简单高效； 单向数据流，数据维护简单； 支持JSX； 支持数据渲染； 可以采用后端JS开发模式。 其他技术介绍： Redux：数据层框架，采用事件模型进行数据维护，在数据复用和数据同步方面优势明显。 RequireJS：按需加载JS Zepto：移动端使用的jQuery替代技术 UIKit：前端UI框架，类似于Bootstrap，技术成熟，使用相对简单； SUI：移动端UI框架，淘宝团队开发，采用iOS风格；新框架，迭代很快，几天一个版本，坑比较少 ReactRouter：针对ReactJS的单页面框架 ES6支持：可以使用ES6语法进行开发，生产环境使用Babel等转义到ES5运行。 浏览器支持情况：IE8+ 学习成本：主要学习成本在于React、Redux和jQuery。React API很简单，入手大概1.5天；Redux学习成本大概一天。 技术成熟度：技术成熟，背景比较强大，很多互联网公司的产品正在逐步迁移到React，比如美团、乐视、阿里等；基于React的React Native，是Facebook 15年刚发布的移动开发开源技术，现在国内已经有部分APP在尝试了。 其他 IDE：intellj idea webstorm 包管理：nodejs，npm，bowerBower:https://segmentfault.com/a/1190000002971135 代码结构：angular-seed，yeoman，自定义 参考：http://angularjs.cn/A04g 测试：karma，jasmine 构建：grunt","categories":[{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/categories/研发管理/"}],"tags":[{"name":"研发管理","slug":"研发管理","permalink":"http://youyunyin.com/tags/研发管理/"}]},{"title":"Java原生实现分页方案","slug":"java原生实现分页方案","date":"2015-05-28T16:00:00.000Z","updated":"2019-01-19T08:20:09.870Z","comments":true,"path":"2015/05/29/java原生实现分页方案/","link":"","permalink":"http://youyunyin.com/2015/05/29/java原生实现分页方案/","excerpt":"","text":"两种分页方式 截取lisit 生成特定分页sql（不同数据库分页sql不同） 方案一 截取list截取list，针对后台查询出来的list数据，前台传入当前页currentPage，每页记录数numPerPage,从而计算出当前页的起始和终止下标，截取list返回前台。 实现： PaginationInfo 分页信息对象 PaginationUtil 分页工具类，传入原始全量list，根据前台传入的页码每页数据量进行截取 如下关键代码 1234567891011121314151617181920212223if(\"pagedemo\".equals(action))&#123;//每页显示数据条数 int numPerPage = 5; //要显示的页int currentPage = Integer.parseInt((String)request.getParameter(\"currentPage\")); StringBuffer json = new StringBuffer(); List&lt;UserVO&gt; list = new ArrayList&lt;UserVO&gt;(); try &#123; //要显示的所有数据 list = userMngService.queryAllUser(); //第一种分页方式，先取所有list，然后截取list分页 PaginationUtil&lt;UserVO&gt; paginationUtil = new PaginationUtil&lt;UserVO&gt;(); PaginationInfo&lt;UserVO&gt; paginationInfo = paginationUtil.listDataProcess(list, numPerPage, currentPage); //要显示的数据 list = paginationInfo.getResultList(); json.append(\" &#123;\\\"total\\\":\"); //数据总数 json.append(paginationInfo.getTotalPages()); json.append(\",\\\"rows\\\":[ \"); for(int i = 0;i&lt;list.size();i++)&#123; . . . . . . &#125; 步骤： 获取前台传参数当前页currentPage, 设置分页规则：每页记录数 获取要显示的所有数据信息list 使用工具类PaginationUtil截取list。返回PaginationInfo对象 PaginationInfo对象中包含了结果relustList页码，总记录数等信息，根据需要取得数据返回json到前台。 方案二 特定分页sql 在需要进行分页处理的DMO类中使用JdbcPaginationDelegator代理类处理，使用PaginationInfo对象存储数据信息。结果list，总页数等示例:123456789/** * 查询所有用户信息 分页 * @param currentPage 当前页 * @param numPerPage 每页显示数据条数 * @return */ Public PaginationInfo&lt;UserVO&gt; queryUserByPageInfo(int currentPage,int numPerPage)&#123; 。。。。 &#125; 步骤： 创建基本查询sql 12StringBuffer sql = new StringBuffer();sql.append(\"select * from ump_user where dr = ?\"); 创建分页信息对象，分页工具代理，如需sql参数创建sql参数对象SQLParameter，如果没有则传null 1234567//分页信息PaginationInfo&lt;UserVO&gt; pagenationInfo = new PaginationInfo&lt;UserVO&gt;();//jdbc分页代理对象JdbcPaginationDelegator&lt;UserVO&gt; delegate = new JdbcPaginationDelegator&lt;UserVO&gt;();//sql参数信息SQLParameter param = new SQLParameter();param.addParam(0); 使用代理对象初始化分页信息 123//使用代理对象初始化分页信息，代理类中会计算总记录数，但是不会执行分页sql，因为很多没有使用元数据没有，vo和数据表的映射//所以没法自动的将rs生成vo，所以，代理只是生成分页特定数据库的分页sql语句，由调用对象自行执行。pagenationInfo = delegate.initPaginationInfo(sql.toString(), param, currentPage, numPerPage); 执行代理类生成的分页SQL 1234//执行代理类生成的分页查询sqlstmt = conn.prepareStatement(paginationInfo.getPageSql());stmt.setInt(1, 0);rs = stmt.executeQuery(); 两种方式对比：两种方案的优劣比较明显，截取list每次都要全查出来，如果list的数据量非常大每次全查耗时较多，可考虑方案二，但是，此方案改动的代码量少，只需要在action加几行代码处理即可。 使用分页sql，方案效率较高，每次只取需要的数据，劣势在于需更改的代码较多，同时如果涉及到多次联查取综合数据的场景则此方案无效，只能使用方案一。","categories":[{"name":"java","slug":"java","permalink":"http://youyunyin.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://youyunyin.com/tags/java/"}]}]}